# 第五章
## 5.1I/O系统的功能、模型和接口
* 管理对象：I/O设备和相应的设备控制器
### 5.1.1I/O系统的基本功能
* 隐藏物理设备的细节：I/O设备的类型非常多，且彼此间在多方面都有差异，I/O系统必须通过对设备加以适当的抽象，隐藏物理设备的实现细节，仅向上层进程提供少量、抽象的读写命令。
* 与设备的无关性：隐藏物理设备的细节，可方便用户对设备的使用。无关性不仅可以让用户使用抽象的I/O命令，还可使用抽象的逻辑设备名来使用设备，并可以有效地提高OS的可移植性和易适应性。
* 提高处理机和I/O设备的利用率：尽可能地让处理机和I/O设备并行操作，以提高它们的利用率。
* 对I/O设备进行控制：目前对I/O设备有四种控制方式：① 采用轮询的可编程I/O方式；② 采用中断的可编程I/O方式；③ 直接存储器访问方式；④ I/O通道方式。
* 确保对设备的正确共享：从设备的共享属性上，可将系统中的设备分为如下两类：(1) 独占设备，进程应互斥地访问这类设备。　　(2) 共享设备，是指在一段时间内允许多个进程同时访问的设备。典型的共享设备是磁盘，当有多个进程需对磁盘执行读、写操作时，可以交叉进行，不会影响到读、写的正确性。
* 错误处理：大多数的设备都包括了较多的机械和电气部分，运行时容易出现错误和故障。　
### 5.1.2I/O系统的层次结构和模型
![name1](https://github.com/fang50253/NJFU_OS_NoteBook/blob/main/pic/5.1.2IO%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E6%A8%A1%E5%9E%8B.png?raw=true)
### 6.1.3I/O系统接口
* 块设备接口：块设备、隐藏了磁盘的二维结构、将抽象命令映射为低层操作。
* 流设备接口：流设备接口是流设备管理程序与高层之间的接。
* 网络通信接口
## 5.2I/O设备和设备控制器
### 5.2.1I/O设备
#### 两种分类模式
* 按使用特性分类
* 按传输速率分类
#### 设备与控制器之间的接口
* 数据信号线
* 控制信号线
* 状态信号线
### 5.2.2设备控制器
#### 设备控制器的基本功能
* 接收和识别命令
* 数据交换
* 标识和报告设备的状态
* 地址识别
* 数据缓冲区
* 差错控制
#### 设备控制器的组成
* 设备控制器与处理机的接口
* 设备控制器与设备的接口
* I/O逻辑
### 5.2.3I/O通道
#### 引入原因
* 当主机所配置的外设很多时，CPU的负担仍然很重
#### 通道类型
* 字节多路通道(Byte Multiplexor Channel)
* 数组选择通道(Block Selector Channel)
* 数组多路通道(Block Multiplexor Channel)
#### 瓶颈问题
![pic1](https://github.com/fang50253/NJFU_OS_NoteBook/blob/main/pic/5.2.4%E7%93%B6%E9%A2%88%E9%97%AE%E9%A2%98.png?raw=true)
* 由于通道价格昂贵，致使机器中所设置的通道数量势必较少，这往往又使它成了I/O的瓶颈，进而造成整个系统吞吐量的下降
## 5.3中断机构和中断处理程序
* 中断的重要性：进程之间的切换、中断是设备管理的基础
### 5.3.1中断简介
* 中断：由外部设备引起的，CPU对I/O设备发来的中断信号的响应
* 陷入：由CPU内部事件引起的中断，如运算出现上溢或下溢、程序出错等，称内中断或陷入
* 中断向量表：为每种设备配以相应的中断处理程序，将该程序的入口地址放在中断向量表的一个表项中，为每个设备的中断请求规定一个中断号，对应于中断向量表的一个表项。
* 中断优先级：根据每个中断源对服务要求的紧急程度，分别规定不同的优先级。
* 对中断源的处理方式：屏蔽(禁止)中断、嵌套中断
### 5.3.2中断处理程序
* 当一个进程请求I/O 操作时，该进程将被挂起，直到I/O设备完成I/O操作后，设备控制器便向CPU发送一个中断请求，CPU响应后便转向中断处理程序，中断处理程序执行相应的处理，处理完后解除相应进程的阻塞状态。
## 5.4设备驱动程序
* 主要任务：接收上层软件发来的抽象I/O要求，把它转换为具体要求后，发送给设备控制器，启动设备去执行。
### 5.4.1设备驱动程序概述
#### 设备驱动程序的功能
* 接收由与设备无关的软件发来的命令和参数，并将命令中的抽象要求转换为与设备相关的低层操作序列。
* 检查用户I/O请求的合法性，了解I/O设备的工作状态，传递与I/O设备操作有关的参数，设置设备的工作方式。
* 发出I/O命令，如果设备空闲，便立即启动I/O设备，完成指定的I/O操作；如果设备忙碌，则将请求者的请求块挂在设备队列上等待。
* 及时响应由设备控制器发来的中断请求，并根据其中断类型，调用相应的中断处理程序进行处理。
#### 设备驱动程序的特点(与一般应用程序、系统程序的差异)
* 驱动程序是实现在与设备无关的软件和设备控制器之间通信和转换的程序，具体说，它将抽象的I/O请求转换成具体的I/O操作后传送给控制器。又把控制器中所记录的设备状态和I/O操作完成情况，及时地反映给请求I/O的进程。
* 驱动程序与设备控制器以及I/O设备的硬件特性紧密相关，对于不同类型的设备，应配置不同的驱动程序。
* 驱动程序与I/O设备所采用的I/O控制方式紧密相关，常用的I/O控制方式是中断驱动和DMA方式。
* 由于驱动程序与硬件紧密相关，因而其中的一部分必须用汇编语言书写。目前有很多驱动程序的基本部分已经固化在ROM中。
* 驱动程序应允许可重入。一个正在运行的驱动程序常会在一次调用完成前被再次调用。
### 5.4.2设备驱动程序的处理过程
* 将抽象要求转换为具体要求→对服务请求进行校验→检查设备的状态→传送必要的参数→启动I/O设备
### 5.4.3对I/O设备的控制方式
* 使用轮询的可编程I/O方式
* 使用中断的可编程I/O方式
#### 直接存储器访问方式（DMA）
##### 特点
* 数据传输的基本单位是数据块，即在CPU与I/O设备之间，每次传送至少一个数据块。
* 所传送的数据是从设备直接送入内存的，或者相反。
* 仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在控制器的控制下完成的。
##### DMA
* 接存储器访问方式的引入
* DMA控制器的组成：主机与DMA控制器的接口；DMA控制器与块设备的接口；I/O控制逻辑
* DMA工作过程
#### I/O通道的控制方式
* 引入原因：而当我们需要一次去读多个数据块且将它们分别传送到不同的内存区域，或者相反时，则须由CPU分别发出多条I/O指令及进行多次中断处理才能完成。
* 通道程序：通道是通过执行通道程序并与设备控制器共同实现对I/O设备的控制的。通道程序是由一系列通道指令(或称为通道命令)所构成的。
## 5.5与设备无关的I/O软件
### 5.5.1与设备无关软件的基本概念
* 以物理设备名使用设备
* 引入逻辑设备名
* 逻辑设备名称到物理设备名称到转换
### 5.5.2与设备无关的软件
* 设备驱动程序的统一接口：为了使所有的设备驱动程序有着统一的接口，一方面，要求每个设备驱动程序与OS之间都有着相同的接口，或者相近的接口，这样会使添加一个新的设备驱动程序变得很容易，同时在很大程度上方便了开发人员对设备驱动程序的编制。另一方面，要将抽象的设备名映射到适当的驱动程序上，或者说，将抽象的设备名转换为具体的物理设备名，并进一步可以找到相应物理设备的驱动程序入口。
* 缓冲管理：无论是字符设备还是块设备，它们的运行速度都远低于CPU的速度。为了缓和CPU和I/O设备之间的矛盾、提高CPU的利用率，在现代OS中都无一例外地分别为字符设备和块设备配置了相应的缓冲区。缓冲区有着多种形式，如单缓冲区、双缓冲区、循环缓冲区、公用缓冲池等，以满足不同情况的需要。
* 差错控制：由于设备中有着许多的机械和电气部分，因此，它们比主机更容易出现故障，这就导致I/O操作中的绝大多数错误都与设备有关。
* 对独立设备的分配与回收：在系统中有两类设备：独占设备和共享设备。对于这两类设备的分配方式不同。
* 独立于设备的逻辑数据块：不同类型的设备，其数据交换单位是不同的，读取和传输速率也各不相同，如字符型设备以单个字符(字)为单位，块设备是以一个数据块为单位。设备独立性软件应能够隐藏这些差异而被逻辑设备使用，并向高层软件提供大小统一的逻辑数据块。
### 5.5.3设备分配
#### 设备分配中的数据结构
* 设备控制表DCT
* 控制器控制表COCT、通道控制表CHCT和系统设备表SDT
#### 设备分配时应考虑的因素
* 设备的固有属性：独占设备的分配策略、共享设备的分配策略，虚拟设备的分配策略
* 设备分配算法：先来先服务、高优先级者优先
* 设备分配中的安全性：安全分配方式、不安全分配方式
#### 独占设备分配程序
* 基本设备分配程序：分配设备、分配控制器、分配通道
* 设备分配程序的改进：在上面的例子中，进程是以物理设备名提出I/O请求的。如果所指定的设备已分配给其它进程，则分配失败。或者说上面的设备分配程序不具有与设备无关性。为获得设备的独立性，进程应使用逻辑设备名请求I/O。
### 5.5.4逻辑设备名到物理设备名映射到实现
* 逻辑设备表LUT(Logical Unit Table)逻辑设备名、物理设备名、逻辑驱动程序入口地址
* 逻辑设备表的设置问题：整个系统只设置一个LUT、每个用户设置一张LUT
![pic2](https://github.com/fang50253/NJFU_OS_NoteBook/blob/main/pic/5.5.4%E8%AE%BE%E5%A4%87%E5%90%8D%E6%98%A0%E5%B0%84%E7%9A%84%E5%AE%9E%E7%8E%B0.png?raw=true)
## 5.6用户层的I/O软件
### 5.6.1系统调用与库函数
* 系统调用：一方面，为使诸进程能有条不紊地使用I/O设备，且能保护设备的安全性，不允许运行在用户态的应用进程去直接调用运行在核心态(系统态)的OS过程。但另一方面，应用进程在运行时，又必须取得OS所提供的服务，否则，应用程序几乎无法运行。为了解决此矛盾，OS在用户层中引入了一个中介过程——系统调用，应用程序可以通过它间接调用OS中的I/O过程，对I/O设备进行操作。
* 库函数：在C语言以及UNIX系统中，系统调用(如read)与各系统调用所使用的库函数(如read)之间几乎是一一对应的。而微软定义了一套过程，称为Win32 API的应用程序接口(Application Program Interface)，程序员利用它们取得OS服务，该接口与实际的系统调用并不一一对应。用户程序通过调用对应的库函数使用系统调用，这些库函数与调用程序连接在一起，被嵌入在运行时装入内存的二进制程序中。
### 5.6.2·假脱机(Spooling)系统
* 假脱机技术：在20世纪50年代，为了缓和CPU的高速性与I/O设备低速性间的矛盾，而引入了脱机输入/输出技术。该技术是利用专门的外围控制机，先将低速I/O设备上的数据传送到高速磁盘上，或者相反。这样当处理机需要输入数据时，便可以直接从磁盘中读取数据，极大地提高了输入速度。反之，在处理机需要输出数据时，也可以很快的速度把数据先输出到磁盘上，处理机便可去做自己的事情。
* SPOOLing的组成：输入井和输出井，输入缓冲区和输出缓冲区、输入进程和输出进程、井管理程序
* SPOOLing系统的特点：提高了I/O的速度、将独占设备改造为共享设备、实现了虚拟设备功能。
* 假脱机打印机系统：磁盘缓冲区、打印缓冲区、假脱机管理进程和假脱机打印进程
![pic3](https://github.com/fang50253/NJFU_OS_NoteBook/blob/main/pic/5.6.2SPOOLing%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90.png?raw=true)
## 5.7缓冲区管理
### 5.7.1缓冲的引入
* 缓和CPU与I/O设备间速度不匹配的矛盾
* 减少对CPU的中断频率，放宽对CPU中断响应时间的限制
* 解决数据粒度不匹配的问题
* 提高CPU和I/O设备之间的并行性
### 5.7.2单缓冲区和双缓冲区
* 单缓冲区(Single Buffer)：在单缓冲情况下，每当用户进程发出一I/O请求时，操作系统便在主存中为之分配一缓冲区
* 双缓冲区(Double Buffer)：由于缓冲区是共享资源，生产者与消费者在使用缓冲区时必须互斥。如果消费者尚未取走缓冲区中的数据，即使生产者又生产出新的数据，也无法将它送入缓冲区，生产者等待。如果为生产者与消费者设置了两个缓冲区，便能解决这一问题。
### 5.7.3环形缓冲区
* 环形缓冲区的组成：多个缓冲区、多个指针
* 环形缓冲区的使用：Getbuf过程、Releasebuf过程
* 进程之间的同步问题：Nexti指针追上Nextg指针、Nextg指针追上Nexti指针
### 5.7.4·缓冲池(Buffer Pool) 
* 空白缓冲队列emq
* 输入队列inq
* 输出队列outq
## 5.8磁盘存储器的性能和调度
### 5.8.1磁盘性能简述
* 磁盘设备是一种相当复杂的机电设备，在此仅对磁盘的某些性能，如数据的组织、磁盘的类型和访问时间等方面做扼要的阐述。
* 数据的组织和格式：·磁盘设备可包括一个或多个物理盘片，每个磁盘片分一个或两个存储面(Surface，每个盘面上有若干个磁道(Track)，磁道之间留有必要的间隙(Gap)。为使处理简单起见，在每条磁道上可存储相同数目的二进制位
* 磁盘的类型：硬盘和软盘、单片盘和多片盘、固定头磁盘和活动头(移动头)磁盘
* 磁盘访问时间：磁盘设备在工作时以恒定速率旋转。为了读或写，磁头必须能移动到所指定的磁道上，并等待所指定的扇区的开始位置旋转到磁头下，然后再开始读或写数据
* 磁盘访问时间包括：寻道时间、旋转延迟时间、传输时间
### 5.8.2早起磁盘调度算法
* 先来先服务(FCFS)：这是最简单的磁盘调度算法。它根据进程请求访问磁盘的先后次序进行调度。
![pic3](https://github.com/fang50253/NJFU_OS_NoteBook/blob/main/pic/5.8.2%E6%97%A9%E6%9C%9F%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.png?raw=true)
* 最短寻道时间优先(SSTF)：该算法选择这样的进程，其要求访问的磁道与当前磁头所在的磁道距离最近，以使每次的寻道时间最短，但这种算法不能保证平均寻道时间最短。
![pic4](https://github.com/fang50253/NJFU_OS_NoteBook/blob/main/pic/5.8.2SSTF.png?raw=true)
### 5.8.3基于扫描的磁盘调度算法
* 扫描(SCAN)算法：SSTF算法的实质是基于优先级的调度算法，因此就可能导致优先级低的进程发生“饥饿”(Starvation)现象。因为只要不断有新进程的请求到达，且其所要访问的磁道与磁头当前所在磁道的距离较近，这种新进程的I/O请求必然优先满足。扫描算法（SCAN）不仅考虑到欲访问的磁道与当前磁道的距离，更优先考虑的是磁头的当前移动方向。当磁头正在由里向外移动时，SCAN算法所选择的下一个访问对象应是其欲访问的磁道，既在当前磁道之外，又是距离最近的。这样由里向外地访问，直至再无更外的磁道需要访问时，才将磁臂换向，由外向里移动。这时，同样也是每次选择在当前磁道之内，且距离最近的进程来调度。
![pic4](https://github.com/fang50253/NJFU_OS_NoteBook/blob/main/pic/5.8.3%E5%9F%BA%E4%BA%8E%E6%89%AB%E6%8F%8F.png?raw=true)
* 循环扫描(CSCAN)算法：SCAN算法既能获得较好的寻道性能，又能防止“饥饿”现象，故被广泛用于大、中、小型机器和网络中的磁盘调度。但也存在这样的问题：当磁头刚从里向外移动而越过了某一磁道时，恰好又有一进程请求访问此磁道，这时，该进程必须等待，待磁头继续从里向外，然后再从外向里扫描完处于外面的所有要访问的磁道后，才处理该进程的请求，致使该进程的请求被大大地推迟。
![pic4](https://github.com/fang50253/NJFU_OS_NoteBook/blob/main/pic/5.8.3CSCAN.png?raw=true)
* NStepSCAN算法：在SSTF、SCAN及CSCAN几种调度算法中，都可能出现磁臂停留在某处不动的情况，例如，有一个或几个进程对某一磁道有较高的访问频率，即这个(些)进程反复请求对某一磁道的I/O操作，从而垄断了整个磁盘设备。我们把这一现象称为“磁臂粘着”(Armstickiness)。在高密度磁盘上容易出现此情况。NStepSCAN算法是将磁盘请求队列分成若干长度为N的子队列，按FCFS算法依次处理这些子队列。
* FSCAN调度算法：FSCAN算法实质上是N步SCAN算法的简化，即FSCAN只将磁盘请求队列分成两个子队列。一个是由当前所有请求磁盘I/O的进程形成的队列，由磁盘调度按SCAN算法进行处理。另一个是在扫描期间，将新出现的所有请求磁盘I/O的进程放入等待处理的请求队列。这样，所有的新请求都将被推迟到下一次扫描时处理。