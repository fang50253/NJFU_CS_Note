# 算法分析考前复习

upd:2025-12-10

## 第一章：算法引论

### 1.4 算法复杂性的分析

方法：根据渐近阶的定义，只需要保留函数中最高阶的项，并去除前面的系数

O(1) < O(\log n) < O(n) < O(n \log n) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)

O()：平均复杂度

Ω()：最优复杂度

θ()：最坏复杂度

## 第二章：递归和分治策略

![pic1](https://github.com/fang50253/NJFU_CS_Note/blob/main/25-26-1%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/emphsis/pic1.png?raw=true)

```java
Type divide_and_conputer(P)
{
	if(|P|<n)
		ad(P);//当P的规模足够小，我们可以直接处理P
	divide P into small subinstances p1,p2,...,pk;
	for(int i=1;i<=k;++i)
		yi=divide_and_conputer(pi);
		//递归求解各个子问题
	return merge(y1,y2,...,yk);
	//将哥哥子问题的解进行合并得到最终问题的解
}
```

1. 分解-解决-合并的思路，定义了解，不考定义，不考简答题

2. 分支算法的基本框架

3. 递归函数(阶乘)，代码题不一定会考很复杂的，短的话3-5行，长的话十几行

```java
public static int factorial(int n)
{
	if(n==0) return 1;
	return n*factorial(n-1);
}
```

4. 递归的过程，不断地调用自身的过程

5. 汉诺塔问题，考代码题的可能性会更大一点，代码在20页，代码记忆：a,c,b   ->   c,b,a

```java
public static void hanoi(int n,int a,int b,int c)
{
	if(n>0)
	{
		hanoi(n-1,a,c,b);
		move(a,b);
		hanoi(n-1,c,b,a);
	}
}
```

6. 二分搜索，大概率是考代码题

```java
public static int binarySearch(int[] a,int x,int n)
{
	//在a[0]<=a[1]<=...<=a[n-1]中搜索x
	//找到x时返回其在数组中的位置，否则返回-1
	int left=0;
	int right=n-1;
	while(left<=right)
	{
		int middle=(left+right)/2;
		if(x==a[middle]) return middle;
		if(x>a[middle]) left=middle+1;
		else right=middle-1;
	}
	return -1;
}
```

7. 排序问题，2.7 2.8。但是考试不能这么写。考试不考冒泡排序，

![pic2](https://github.com/fang50253/NJFU_CS_Note/blob/main/25-26-1%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/emphsis/pic2.png?raw=true)

8. 2.5矩阵乘法的可能性不大，3.1的矩阵连乘问题更适合。2.5如果想高分可以看

9. 快速排序每一次只动不是基准的那一面，基准是不会移动的。

## 第三章：dp 3.1 3.3 3.9(3.2只要知道概念，不是重点)这个章节比较容易出推理题

1. 最优子结构，重叠子问题

2. 矩阵连乘问题，选择不同的括号，画出2张表

![pic3](https://github.com/fang50253/NJFU_CS_Note/blob/main/25-26-1%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/emphsis/pic3.png?raw=true)

![pic4](https://github.com/fang50253/NJFU_CS_Note/blob/main/25-26-1%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/emphsis/pic4.png?raw=true)

3. 最长公共子序列问题，构造最优解的性质，画出表

4. 01背包问题。

![pic5](https://github.com/fang50253/NJFU_CS_Note/blob/main/25-26-1%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/emphsis/pic5.png?raw=true)
￼
## 第四章：贪心算法

4.1 活动安排问题，考代码的可能性会更大。策略是结束的早的优先。

```java
public static int greedySelector(int []s,int []f,boolean a[])
{
	int n=s.length-1;
	a[1]==true;//这里注意！！java不允许用1代表true！！！
	int j=1;
	int count=1;
	for(int i=2;i<=2;++i)
	{
 		if(s[i]>f[j])
		{
			a[i]=true;
			j=i;
			count++;
		}
		else a[i]=false;
	}
	return count;
} 
```

4.2 性质：最优子结构

4.5 推理，dijkstra，考推理，集合那边按照进入顺序排序
￼
![pic6](https://github.com/fang50253/NJFU_CS_Note/blob/main/25-26-1%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/emphsis/pic6.png?raw=true)

记录路径是通过u构造prev[]数组

4.6 最小生成树 prim+kruskal

Prim，从任意一个边开始，每次选择离联通块最近的一个点

Kruskal，从最短的边开始，不允许成环。

## 第五章：回溯法（dfs，80%可能考代码题）

![pic7](https://github.com/fang50253/NJFU_CS_Note/blob/main/25-26-1%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/emphsis/pic7.png?raw=true)

1. 子集树

```java
void backtrack(int t)
{
	if(t>n) output(x);
	else
	{
		for(int i=0;i<=1;++i)
		{
			x[t]=i;
			if(legal(t)) backtrack(t+1);
		}
	}
}
```
￼
2. 排列树

```java
void backtrack(int t)
{
	if(t>n) output(x);
	else
	{
		for(int i=t;i<=n;++i)
		{
			swap(x[t],x[i]);
			if(legal(t)) backtrack(t+1);
			swap(x[t],x[i]);
		}
	}
}
```

## 第六章：分支界限（bfs，考推理题的可能性大）

6.1:如果只追求几个，只要看6.1，80%可能只考6.1

子集树和排列树，队列式和优先队列式，加起来有4种情况

6.2旅行售货员问题，队列式按照先进先出，优先队列式（画一张图+表）
