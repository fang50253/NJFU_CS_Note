private static void backtrack(int i)
{
    if(i>n)
    //每到达一个叶子结点，一定是产生了一个最优解，因此更要更新之前最优解的值
    {
        for(int j=1;j<=n;++j) bestx[j]=x[j];//更新最优解
        bestf=f;
    }
    else
    {
        for(int j=i;j<=n;++j)
        //控制展开i-1层结点的各个分支，例如当i=1时，表示在整棵排列树刚要开始探索结点，这里可以展开的分支有1、2、3
        {
            f1+=m[x[j]][1];//计算第i层/个作业在机器1上的完成处理的时间
            f2[i]=((f2[i-1]>f1)?f2[i-1]:f1)+m[x[j]][2];//如果第i-1个作业在机器2上的完成处理时间大于第i个作业在机器1上完成的时间，那么第i个作业想要进入机器2，就要等第i-1个作业在机器2上完成后再说，否则第i个作业可以在机器1上完成处理后直接进入机器2
            f+=f2[i];//计算完第i个作业在机器2上的完成处理的时间，就可以计算出前i个作业在机器2上完成处理的时间和了
            if(f<bestf)
            //截止到这里，已经得到了一个前i个作业在机器2上完成处理的时间和f，如果f比之前记录的第i个作业在机器2上的完成处理的时间和的最优值bestf小，就可以生成第i层结点的孩子结点，继续探索下一层
            {
                MyMath.swap(x,i,j);//把处于同一层的并且使f更小的那个结点拿过来，放到正在探索的这个结点处
                backtrack(i+1);//继续探索以第i层结点为根结点的子树
                MyMath.swap(x,i,j);//探索完要回溯时，只要做探索钱的反动作就可以了
            }
            f1-=m[x[j]][1];//探索完要回溯时，只要做探索前的反动作就可以了
            f-=f2[i];//探索完要回溯时，只要做探索前的反动作就可以了
        }
    }
}