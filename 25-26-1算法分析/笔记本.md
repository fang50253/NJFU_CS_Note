# 算法引论
## 1.1 算法与程序

### 算法和程序的区别
算法：输入、输出、确定性、有限性

程序可以不满足有限性

### 算法的抽象机制
在设计和实现算法的时候将问题和解决方案抽象化，便于理解、实现、优化。帮助简化复杂问题

### 运算种类
基本运算、复杂运算(函数运算、向量运算、矩阵运算、集合运算、表、堆、栈、队列，图)、复合运算(分治)

### 算法结构
顺序结构、选择结构、循环结构

### 顶层运算、底层运算
顶层运算：py、java、matlab

底层运算 011+101->1000

## 1.2 表达程序的抽象机制
算法指令传递执行的载体：程序设计语言

第一章大概率是考复杂度，后面是计算题/代码题/模拟推理题

# 递归与分治策略
## 2.1递归的概念

### 分治法的模板

```java
Type divide_and_conputer(P)
{
	if(P<=n)
		ad(P);
	divide P into smaller subinstances p1,p2,...,pk;
	for(int i=1;i<=k;i++)
		yi=divide_and_conputer(pi);
		//递归求解各个子问题
	return merge(y1,y2,......,yk);
	//将各个子问题的解进行合并得到最终问题的解	
}
```
时间复杂度分析：
原函数时间为T(n),每个子问题是kT(n/n),最优子结构计算时间为O(1),合并过程是f(n)

T(n)=kT(n/m)+f(n)

T(n/m)=kT(n/m^2)+f(n/m)

... ...

### 第2章考试范围
例题：2.1  2.2  2.4  2.6
#### 汉诺塔问题
```java
public static void hanoi(int n,int a,int b,int c)
{
	if(n>0)
	{
		hanoi(n-1,a,c,b);
		move(a,b);
		hanoi(n-1,c,b,a);
	}
}
```

2.5 Strassen矩阵乘法只考原理不考代码

2.7 合并排序


# 贪心算法
### 第四章考试范围
## 4.1 

# 回溯法
### 第五章考试范围

5.1 5.2 5.3 5.4 5.5 5.8

### 5.1回溯法的基本框架
```java
void traceback(int t)
{
	if(t>n) output(x);
	//如果当前递归步数t超过了问题规模n，则调用output(x)输出解x，通常表示找到一个满足约束条件的解
	else
	//如果t没有超过n，则继续递归处理
	//循环遍历从f(n,t)到g(n,t)的所有可能值，f(n,t) g(n,t)通常表示当前层次或者步骤，t是可以选择的范围
	{
		for(int i=f(n,t);i<=g(n,t);i++)
		{
			x[i]=h(i);
			//将i经过函数h(i)的处理结果赋值给x[t],即当前解的第t个元素，h(i)通常是表示在当前扩展节点处x[t]的第i个可选值
			//判断当前步骤t的解是否满足constraint(t)(约束函数)以及bound(t)（限界函数，是否在合理界限内),如果都满足，则递归调用backtrace(t+1)，即继续尝试下一步
			if(constaraint(t)&&bound(t)) backtrace(t+1);
			//对其子树做进一步搜索
		}
	}
}
```

### 5.2子集树和排列树

遍历子集树需要O(2<sup>n</sup>)计算时间

```java
void backtrack(int t)
{
	if(t>n) output(x);
	else
	{
		for(int i=0;i<=1;++i)
		{
			x[t]=i;
			if(legal(t)) backtrack(i+1);
		}
	}
}

```

遍历排列树需要O(n!)计算时间

```java
void backtrack(int t)
{
	if(t>n) output(x);
	else
	{
		for(int i=t;i>=n;++i)
		//第t个元素和之后的元素进行交换位置
		{
			swap(x[t],x[i]);
			if(legal(t)) backtrack(t+1);
			swap(x[t],x[i]);
		}
	}
}
```

批处理作业调度
```java
private static void backtrack(int i)
{
    if(i>n)
    //每到达一个叶子结点，一定是产生了一个最优解，因此更要更新之前最优解的值
    {
        for(int j=1;j<=n;++j) bestx[j]=x[j];//更新最优解
        bestf=f;
    }
    else
    {
        for(int j=i;j<=n;++j)
        //控制展开i-1层结点的各个分支，例如当i=1时，表示在整棵排列树刚要开始探索结点，这里可以展开的分支有1、2、3
        {
            f1+=m[x[j]][1];//计算第i层/个作业在机器1上的完成处理的时间
            f2[i]=((f2[i-1]>f1)?f2[i-1]:f1)+m[x[j]][2];//如果第i-1个作业在机器2上的完成处理时间大于第i个作业在机器1上完成的时间，那么第i个作业想要进入机器2，就要等第i-1个作业在机器2上完成后再说，否则第i个作业可以在机器1上完成处理后直接进入机器2
            f+=f2[i];//计算完第i个作业在机器2上的完成处理的时间，就可以计算出前i个作业在机器2上完成处理的时间和了
            if(f<bestf)
            //截止到这里，已经得到了一个前i个作业在机器2上完成处理的时间和f，如果f比之前记录的第i个作业在机器2上的完成处理的时间和的最优值bestf小，就可以生成第i层结点的孩子结点，继续探索下一层
            {
                MyMath.swap(x,i,j);//把处于同一层的并且使f更小的那个结点拿过来，放到正在探索的这个结点处
                backtrack(i+1);//继续探索以第i层结点为根结点的子树
                MyMath.swap(x,i,j);//探索完要回溯时，只要做探索钱的反动作就可以了
            }
            f1-=m[x[j]][1];//探索完要回溯时，只要做探索前的反动作就可以了
            f-=f2[i];//探索完要回溯时，只要做探索前的反动作就可以了
        }
    }
}
```

符号三角形问题
```java
public static void backtrack(int t)
{
    //如果+的个数超过half，或者当前状态下-的个数看你超过half，则返回
    if((count>half)||(t*(t-1)/2-count>half)) return;
    //当t>n时，说明已搜索到叶节点，找到一个符号三角形
    if(t>n) ++sum;//计数器增1，表示找到一个有效的符号三角形
    else
    {
        //遍历+和-的两种情况
        for(int i=0;i<2;++i)
        {
            p[1][t]=i;//设置第1行第t个元素为i
            count+=i;//更新+第个数
            //更新后续行的元素
            for(int j=2;j<=t;++j)//根据规则计算当前符号的状态
            {
                p[j][t-j+1]=p[j-1][t-j+1]^p[j-1][t-j+2];//计算当前状态
                count+=p[j][t-j+1];//更新+的个数
            }
            backtrack(t+1);//递归调用，进入下一层
            //回调，撤销当前赋值
            for(int j=2;j<=t;++j) count-=p[j][t-j+1];//撤销+的计数
            count-=i;//撤销当前选择的符号
        }
    }
}
```