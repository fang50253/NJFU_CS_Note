<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>i5ting_ztree_toc:apiserver</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<h1 id="1-">1.初始化</h1>
<h2 id="1-1-">1.1 创建项目</h2>
<h3 id="1-api_server-">1. 新建api_server文件夹作为项目根目录，并在项目根目录中运行如下的命令，初始化包管理配置文件：</h3>
<blockquote>
<p>npm init -y</p>
</blockquote>
<h3 id="2-express-">2. 运行如下的命令，安装特定版本的 express：</h3>
<blockquote>
<p>npm i <a href="mailto:express@4.17.1">express@4.17.1</a></p>
</blockquote>
<h3 id="3-app-js-">3. 在项目根目录中新建app.js作为整个项目的入口文件，并初始化如下的代码：</h3>
<pre><code>// 导入 express 模块
const express = require(&#39;express&#39;)
// 创建 express 的服务器实例
const app = express()

// write your code here...

// 调用 app.listen 方法，指定端口号并启动web服务器
app.listen(3007, function () {
  console.log(&#39;api server running at http://127.0.0.1:3007&#39;)
})
</code></pre><h2 id="1-2-cors-">1.2 配置 cors 跨域</h2>
<h3 id="1-cors-">1.运行如下的命令，安装 cors 中间件：</h3>
<blockquote>
<p>npm i <a href="mailto:cors@2.8.5">cors@2.8.5</a></p>
</blockquote>
<h3 id="2-app-js-cors-">2.在 app.js 中导入并配置 cors 中间件</h3>
<pre><code>// 导入 cors 中间件
const cors = require(&#39;cors&#39;)
// 将 cors 注册为全局中间件
app.use(cors())
</code></pre><h2 id="1-3-">1.3 配置解析表单数据的中间件</h2>
<h3 id="1-application-x-www-form-urlencoded-">1.通过如下的代码，配置解析 application/x-www-form-urlencoded 格式的表单数据的中间件：</h3>
<blockquote>
<p>app.use(express.urlencoded({ extended: false }))</p>
</blockquote>
<h2 id="1-4-">1.4 初始化路由相关的文件夹</h2>
<h3 id="1-router-">1.在项目根目录中，新建router文件夹，用来存放所有的路由模块</h3>
<blockquote>
<p>路由模块中，只存放客户端的请求与处理函数之间的映射关系</p>
</blockquote>
<h3 id="2-router_handler-">2.在项目根目录中，新建router_handler文件夹，用来存放所有的 路由处理函数模块</h3>
<blockquote>
<p>路由处理函数模块中，专门负责存放每个路由对应的处理函数</p>
</blockquote>
<h2 id="1-5-">1.5 初始化用户路由模块</h2>
<h3 id="1-router-user-js-">1.在 router 文件夹中，新建user.js文件，作为用户的路由模块，并初始化代码如下：</h3>
<pre><code>const express = require(&#39;express&#39;)
// 创建路由对象
const router = express.Router()

// 注册新用户
router.post(&#39;/reguser&#39;, (req, res) =&gt; {
  res.send(&#39;reguser OK&#39;)
})

// 登录
router.post(&#39;/login&#39;, (req, res) =&gt; {
  res.send(&#39;login OK&#39;)
})

// 将路由对象共享出去
module.exports = router
</code></pre><h3 id="2-app-js-">2.在 app.js 中，导入并使用 用户路由模块</h3>
<pre><code>// 导入并注册用户路由模块
const userRouter = require(&#39;./router/user&#39;)
app.use(&#39;/api&#39;, userRouter)
</code></pre><h2 id="1-6-">1.6 抽离用户路由模块中的处理函数</h2>
<blockquote>
<p>目的：为了保证 路由模块 的纯粹性，所有的 路由处理函数，必须抽离到对应的 路由处理函数模块 中</p>
</blockquote>
<h3 id="1-router_handler-user-js-exports-">1.在 /router_handler/user.js中，使用 exports 对象，分别向外共享如下两个 路由处理函数 ：</h3>
<pre><code>/**
 * 在这里定义和用户相关的路由处理函数，供 /router/user.js 模块进行调用
 */

// 注册用户的处理函数
exports.regUser = (req, res) =&gt; {
  res.send(&#39;reguser OK&#39;)
}

// 登录的处理函数
exports.login = (req, res) =&gt; {
  res.send(&#39;login OK&#39;)
}
</code></pre><h3 id="2-router-user-js-">2.将 /router/user.js 中的全部代码替换掉，为如下结构：</h3>
<pre><code>const express = require(&#39;express&#39;)
const router = express.Router()

// 导入用户路由处理函数模块
const userHandler = require(&#39;../router_handler/user&#39;)

// 注册新用户
router.post(&#39;/reguser&#39;, userHandler.regUser)
// 登录
router.post(&#39;/login&#39;, userHandler.login)

module.exports = router
</code></pre><h1 id="2-">2.登录注册</h1>
<h2 id="2-1-ev_users-">2.1 新建 ev_users 表</h2>
<h3 id="1-my_db_01-ev_users-">1.在 my_db_01 数据库中，新建 ev_users 表如下：</h3>
<pre><code>create database my_db_01 character set utf8;
use my_db_01;
create table ev_users(
    id int primary key auto_increment,
    username varchar(255),
    password varchar(255),
    nickname varchar(255),
    email varchar(255),
    user_pic text
);
</code></pre><h2 id="2-2-mysql-">2.2 安装并配置 mysql 模块</h2>
<blockquote>
<p>在 API 接口项目中，需要安装并配置 mysql 这个第三方模块，来连接和操作 MySQL 数据库</p>
</blockquote>
<h3 id="1-mysql-">1.运行如下命令，安装 mysql 模块：</h3>
<blockquote>
<p>npm i <a href="mailto:mysql@2.18.1">mysql@2.18.1</a></p>
</blockquote>
<h3 id="2-db-index-js-">2.在项目根目录中新建 /db/index.js文件，在此自定义模块中创建数据库的连接对象：</h3>
<pre><code>// 导入 mysql 模块
const mysql = require(&#39;mysql&#39;)

// 创建数据库连接对象
const db = mysql.createPool({
  host: &#39;127.0.0.1&#39;,
  user: &#39;root&#39;,
  password: &#39;root&#39;,
  database: &#39;my_db_01&#39;,
})

// 向外共享 db 数据库连接对象
module.exports = db
</code></pre><h2 id="2-3-">2.3 注册</h2>
<h3 id="2-3-0-">2.3.0 实现步骤</h3>
<blockquote>
<p>1.检测表单数据是否合法
2.检测用户名是否被占用
3.对密码进行加密处理
4.插入新用户</p>
</blockquote>
<h3 id="2-3-1-">2.3.1 检测表单数据是否合法</h3>
<h4 id="1-router_handler-user-js-reguser-">1.在 /router_handler/user.js的regUser函数中,判断用户名和密码是否为空</h4>
<pre><code>// 接收表单数据
const userinfo = req.body
// 判断数据是否合法
if (!userinfo.username || !userinfo.password) {
  return res.send({ status: 1, message: &#39;用户名或密码不能为空！&#39; })
}
</code></pre><h3 id="2-3-2-">2.3.2 检测用户名是否被占用</h3>
<h4 id="1-router_handler-user-js-">1.导入数据库操作模块,可以放在/router_handler/user.js文件中的最上面：</h4>
<blockquote>
<p>const db = require(&#39;../db/index&#39;)</p>
</blockquote>
<h4 id="2-sql-">2.定义 SQL 语句：</h4>
<pre><code>const sql = `select * from ev_users where username=?`
</code></pre><h4 id="3-sql-">3.执行 SQL 语句并根据结果判断用户名是否被占用：</h4>
<pre><code>db.query(sql, [userinfo.username], function (err, results) {
  // 执行 SQL 语句失败
  if (err) {
    return res.send({ status: 1, message: err.message })
  }
  // 用户名被占用
  if (results.length &gt; 0) {
    return res.send({ status: 1, message: &#39;用户名被占用，请更换其他用户名！&#39; })
  }
  // TODO: 用户名可用，继续后续流程...
})
</code></pre><h3 id="2-3-3-">2.3.3 对密码进行加密处理</h3>
<blockquote>
<p>为了保证密码的安全性，不建议在数据库以 明文 的形式保存用户密码，推荐对密码进行 加密存储</p>
</blockquote>
<h4 id="1-bcryptjs-">1.运行如下命令，安装指定版本的 bcryptjs ：</h4>
<blockquote>
<p>npm i <a href="mailto:bcryptjs@2.4.3">bcryptjs@2.4.3</a></p>
</blockquote>
<h4 id="2-router_handler-user-js-bcryptjs-">2.在 /router_handler/user.js文件中最上面，导入 bcryptjs ：</h4>
<blockquote>
<p>const bcrypt = require(&#39;bcryptjs&#39;)</p>
</blockquote>
<h4 id="3-bcrypt-hashsync-">3.在注册用户的处理函数中，确认用户名可用之后，调用 bcrypt.hashSync(明文密码, 随机盐的长度) 方法，对用户的密码进行加密处理：</h4>
<pre><code>// 对用户的密码,进行 bcrype 加密，返回值是加密之后的密码字符串
userinfo.password = bcrypt.hashSync(userinfo.password, 10)
</code></pre><h3 id="2-3-4-">2.3.4 插入新用户</h3>
<h4 id="1-sql-">1.定义插入用户的 SQL 语句：</h4>
<blockquote>
<p>const sql = &#39;insert into ev_users set ?&#39;</p>
</blockquote>
<h4 id="2-db-query-sql-">2.调用 db.query() 执行 SQL 语句，插入新用户：</h4>
<pre><code>db.query(sql, { username: userinfo.username, password: userinfo.password }, function (err, results) {
  // 执行 SQL 语句失败
  if (err) return res.send({ status: 1, message: err.message })
  // SQL 语句执行成功，但影响行数不为 1
  if (results.affectedRows !== 1) {
    return res.send({ status: 1, message: &#39;注册用户失败，请稍后再试！&#39; })
  }
  // 注册成功
  res.send({ status: 0, message: &#39;注册成功！&#39; })
})
</code></pre><h2 id="2-4-res-send-">2.4 优化 res.send() 代码</h2>
<blockquote>
<p>在处理函数中，需要多次调用 res.send() 向客户端响应 处理失败 的结果，为了简化代码，可以手动封装一个 res.cc() 函数</p>
</blockquote>
<h3 id="1-app-js-res-res-cc-">1.在 app.js 中，所有路由之前，声明一个全局中间件，放在路由模块上面，为 res 对象挂载一个 res.cc() 函数 ：</h3>
<pre><code>// 响应数据的中间件
app.use(function (req, res, next) {
  // status = 0 为成功； status = 1 为失败； 默认将 status 的值设置为 1，方便处理失败的情况
  res.cc = function (err, status = 1) {
    res.send({
      // 状态
      status,
      // 状态描述，判断 err 是 错误对象 还是 字符串
      message: err instanceof Error ? err.message : err,
    })
  }
  next()
})
</code></pre><h2 id="2-5-">2.5 优化表单数据验证</h2>
<blockquote>
<p>表单验证的原则：前端验证为辅，后端验证为主，后端永远不要相信前端提交过来的任何内容
在实际开发中，前后端都需要对表单的数据进行合法性的验证，而且，后端做为数据合法性验证的最后一个关口，在拦截非法数据方面，起到了至关重要的作用。</p>
</blockquote>
<h3 id="1-joi-">1.安装 joi 包，为表单中携带的每个数据项，定义验证规则：</h3>
<blockquote>
<p>npm install joi</p>
</blockquote>
<h3 id="2-escook-express-joi-">2.安装 @escook/express-joi 中间件，来实现自动对表单数据进行验证的功能：</h3>
<blockquote>
<p>npm i @escook/express-joi</p>
</blockquote>
<h3 id="3-schema-user-js-">3.新建 /schema/user.js用户信息验证规则模块，并初始化代码如下：</h3>
<pre><code>const joi = require(&#39;joi&#39;)

/**
 * string() 值必须是字符串
 * alphanum() 值只能是包含 a-zA-Z0-9 的字符串
 * min(length) 最小长度
 * max(length) 最大长度
 * required() 值是必填项，不能为 undefined
 * pattern(正则表达式) 值必须符合正则表达式的规则
 */

// 用户名的验证规则
const username = joi.string().alphanum().min(1).max(10).required()
// 密码的验证规则
const password = joi
  .string()
  .pattern(/^[\S]{6,12}$/)
  .required()

// 注册和登录表单的验证规则对象
exports.reg_login_schema = {
  // 表示需要对 req.body 中的数据进行验证
  body: {
    username,
    password,
  },
}
</code></pre><h3 id="4-router-user-js-">4.修改 /router/user.js 中的代码全部替换，如下：</h3>
<pre><code>const express = require(&#39;express&#39;)
const router = express.Router()

// 导入用户路由处理函数模块
const userHandler = require(&#39;../router_handler/user&#39;)

// 1. 导入验证表单数据的中间件
const expressJoi = require(&#39;@escook/express-joi&#39;)
// 2. 导入需要的验证规则对象
const { reg_login_schema } = require(&#39;../schema/user&#39;)

// 注册新用户
// 3. 在注册新用户的路由中，声明局部中间件，对当前请求中携带的数据进行验证
// 3.1 数据验证通过后，会把这次请求流转给后面的路由处理函数
// 3.2 数据验证失败后，终止后续代码的执行，并抛出一个全局的 Error 错误，进入全局错误级别中间件中进行处理
router.post(&#39;/reguser&#39;, expressJoi(reg_login_schema), userHandler.regUser)
// 登录
router.post(&#39;/login&#39;, userHandler.login)

module.exports = router
</code></pre><h3 id="5-app-js-">5.在 app.js 的全局错误级别中间件中，捕获验证失败的错误，并把验证失败的结果响应给客户端，必须放在路由模块的下面：</h3>
<pre><code>const joi = require(&#39;joi&#39;)

// 错误中间件
app.use(function (err, req, res, next) {
  // 数据验证失败
  if (err instanceof joi.ValidationError) return res.cc(err)
  // 未知错误
  res.cc(err)
})
</code></pre><h3 id="6-app-js-">6.把文章管理系统的全部文件拷贝到项目根目录下,并在app.js中发布静态资源</h3>
<pre><code>//发布静态资源文件
app.use(express.static(&quot;文章管理系统&quot;))
</code></pre><h2 id="2-6-">2.6登录</h2>
<blockquote>
<p>1.检测表单数据是否合法
2.根据用户名查询用户的数据
3.判断用户输入的密码是否正确
4.生成 JWT 的 Token 字符串</p>
</blockquote>
<h3 id="2-6-1-">2.6.1 检测登录表单的数据是否合法</h3>
<h4 id="1-router-user-js-">1.将 /router/user.js 中 登录 的路由代码修改如下：</h4>
<pre><code>// 登录的路由
router.post(&#39;/login&#39;, expressJoi(reg_login_schema), userHandler.login)
</code></pre><h3 id="2-6-2-">2.6.2 根据用户名查询用户的数据</h3>
<h4 id="1-router_handler-user-js-login-">1.接收表单数据,/router_handler/user.js 中login函数：</h4>
<blockquote>
<p>const userinfo = req.body</p>
</blockquote>
<h4 id="2-sql-">2.定义 SQL 语句：</h4>
<pre><code>const sql = `select * from ev_users where username=?`
</code></pre><h4 id="3-sql-">3.执行 SQL 语句，查询用户的数据：</h4>
<pre><code>db.query(sql, userinfo.username, function (err, results) {
  // 执行 SQL 语句失败
  if (err) return res.cc(err)
  // 执行 SQL 语句成功，但是查询到数据条数不等于 1
  if (results.length !== 1) return res.cc(&#39;登录失败！&#39;)
  // TODO：判断用户输入的登录密码是否和数据库中的密码一致
})
</code></pre><h3 id="2-6-3-">2.6.3 判断用户输入的密码是否正确</h3>
<blockquote>
<p>核心实现思路：调用 bcrypt.compareSync(用户提交的密码, 数据库中的密码) 方法比较密码是否一致
返回值是布尔值（true 一致、false 不一致）</p>
</blockquote>
<h4 id="1-">1.具体的实现代码如下：</h4>
<pre><code>// 拿着用户输入的密码,和数据库中存储的密码进行对比
const compareResult = bcrypt.compareSync(userinfo.password, results[0].password)

// 如果对比的结果等于 false, 则证明用户输入的密码错误
if (!compareResult) {
  return res.cc(&#39;登录失败！&#39;)
}

// TODO：登录成功，生成 Token 字符串
</code></pre><h3 id="2-6-4-jwt-token-">2.6.4 生成 JWT 的 Token 字符串</h3>
<blockquote>
<p>核心注意点：在生成 Token 字符串的时候，一定要剔除 密码 和 头像 的值</p>
</blockquote>
<h4 id="1-es6-">1.通过 ES6 的高级语法，快速剔除 密码 和 头像 的值：</h4>
<pre><code>// 剔除完毕之后，user 中只保留了用户的 id, username, nickname, email 这四个属性的值
const user = { ...results[0], password: &#39;&#39;, user_pic: &#39;&#39; }
</code></pre><h4 id="2-token-">2.运行如下的命令，安装生成 Token 字符串的包：</h4>
<blockquote>
<p>npm i <a href="mailto:jsonwebtoken@8.5.1">jsonwebtoken@8.5.1</a></p>
</blockquote>
<h4 id="3-router_handler-user-js-jsonwebtoken-">3.在 /router_handler/user.js 模块的头部区域，导入 jsonwebtoken 包：</h4>
<pre><code>// 用这个包来生成 Token 字符串
const jwt = require(&#39;jsonwebtoken&#39;)
</code></pre><h4 id="4-config-js-token-jwtsecretkey-">4.根目录下创建 config.js 文件，并向外共享 加密 和 还原 Token 的 jwtSecretKey 字符串：</h4>
<pre><code>module.exports = {
  jwtSecretKey: &#39;abc123456^_^&#39;,
}
</code></pre><h4 id="5-token-">5.将用户信息对象加密成 Token 字符串：</h4>
<pre><code>// 导入配置文件
const config = require(&#39;../config&#39;)

// 生成 Token 字符串
const tokenStr = jwt.sign(user, config.jwtSecretKey, {
  expiresIn: &#39;10h&#39;, // token 有效期为 10 个小时
})
</code></pre><h4 id="6-token-">6.将生成的 Token 字符串响应给客户端：</h4>
<pre><code>res.send({
  status: 0,
  message: &#39;登录成功！&#39;,
  token: &#39;Bearer &#39; + tokenStr,
})
</code></pre><h2 id="2-7-token-">2.7 配置解析 Token 的中间件</h2>
<h3 id="1-token-">1.运行如下的命令，安装解析 Token 的中间件：</h3>
<blockquote>
<p>npm i <a href="mailto:express-jwt@5.3.3">express-jwt@5.3.3</a></p>
</blockquote>
<h3 id="2-app-js-token-">2.在 app.js 中注册路由之前，响应中间件之后，配置解析 Token 的中间件：</h3>
<pre><code>// 导入配置文件
const config = require(&#39;./config&#39;)

// 解析 token 的中间件
const expressJWT = require(&#39;express-jwt&#39;)

app.use(expressJWT({ secret: config.jwtSecretKey }).unless({ path: [/^\/api\//] }))
</code></pre><h3 id="3-app-js-token-">3. 在 app.js 中的 错误级别中间件 里面，捕获并处理 Token 认证失败后的错误：</h3>
<pre><code>// 错误中间件
app.use(function (err, req, res, next) {
  // 省略其它代码...

  // 捕获身份认证失败的错误
  if (err.name === &#39;UnauthorizedError&#39;) return res.cc(&#39;身份认证失败！&#39;)

  // 未知错误...
})
</code></pre><h1 id="3-">3. 个人中心</h1>
<h2 id="3-1-">3.1 获取用户的基本信息</h2>
<h3 id="3-1-0-">3.1.0 实现步骤</h3>
<blockquote>
<p>初始化 路由 模块
初始化 路由处理函数 模块
获取用户的基本信息</p>
</blockquote>
<h3 id="3-1-1-">3.1.1 初始化路由模块</h3>
<h4 id="1-router-userinfo-js-">1.创建 /router/userinfo.js 路由模块，并初始化如下的代码结构：</h4>
<pre><code>// 导入 express
const express = require(&#39;express&#39;)
// 创建路由对象
const router = express.Router()

// 获取用户的基本信息
router.get(&#39;/userinfo&#39;, (req, res) =&gt; {
  res.send(&#39;ok&#39;)
})

// 向外共享路由对象
module.exports = router
</code></pre><h4 id="2-app-js-">2.在 app.js 中导入并使用个人中心的路由模块：</h4>
<pre><code>// 导入并使用用户信息路由模块
const userinfoRouter = require(&#39;./router/userinfo&#39;)
// 注意：以 /my 开头的接口，都是有权限的接口，需要进行 Token 身份认证
app.use(&#39;/my&#39;, userinfoRouter)
</code></pre><h3 id="3-1-2-">3.1.2 初始化路由处理函数模块</h3>
<h4 id="1-router_handler-userinfo-js-">1.创建 /router_handler/userinfo.js 路由处理函数模块，并初始化如下的代码结构：</h4>
<pre><code>// 获取用户基本信息的处理函数
exports.getUserInfo = (req, res) =&gt; {
  res.send(&#39;ok&#39;)
}
</code></pre><h4 id="2-router-userinfo-js-">2.修改 /router/userinfo.js 中的代码如下：</h4>
<pre><code>const express = require(&#39;express&#39;)
const router = express.Router()

// 导入用户信息的处理函数模块
const userinfo_handler = require(&#39;../router_handler/userinfo&#39;)

// 获取用户的基本信息
router.get(&#39;/userinfo&#39;, userinfo_handler.getUserInfo)

module.exports = router
</code></pre><h3 id="3-1-3-">3.1.3 获取用户的基本信息</h3>
<h4 id="1-router_handler-userinfo-js-">1.在 /router_handler/userinfo.js 头部导入数据库操作模块：</h4>
<pre><code>// 导入数据库操作模块
const db = require(&#39;../db/index&#39;)
</code></pre><h4 id="2-sql-">2.定义 SQL 语句：</h4>
<pre><code>// 根据用户的 id，查询用户的基本信息
// 注意：为了防止用户的密码泄露，需要排除 password 字段
const sql = `select id, username, nickname, email, user_pic from ev_users where id=?`
</code></pre><h4 id="3-db-query-sql-">3.调用 db.query() 执行 SQL 语句：</h4>
<pre><code>// 注意：req 对象上的 user 属性，是 Token 解析成功，express-jwt 中间件帮我们挂载上去的
db.query(sql, req.user.id, (err, results) =&gt; {
  // 1. 执行 SQL 语句失败
  if (err) return res.cc(err)

  // 2. 执行 SQL 语句成功，但是查询到的数据条数不等于 1
  if (results.length !== 1) return res.cc(&#39;获取用户信息失败！&#39;)

  // 3. 将用户信息响应给客户端
  res.send({
    status: 0,
    message: &#39;获取用户基本信息成功！&#39;,
    data: results[0],
  })
})
</code></pre><h2 id="3-2-">3.2 更新用户的基本信息</h2>
<h3 id="3-2-0-">3.2.0 实现步骤</h3>
<blockquote>
<p>定义路由和处理函数
验证表单数据
实现更新用户基本信息的功能</p>
</blockquote>
<h3 id="3-2-1-">3.2.1 定义路由和处理函数</h3>
<h4 id="1-router-userinfo-js-">1.在 /router/userinfo.js 模块中，新增 更新用户基本信息 的路由：</h4>
<pre><code>// 更新用户的基本信息
router.post(&#39;/userinfo&#39;, userinfo_handler.updateUserInfo)
</code></pre><h4 id="2-router_handler-userinfo-js-">2.在 /router_handler/userinfo.js 模块中，定义并向外共享 更新用户基本信息 的路由处理函数：</h4>
<pre><code>// 更新用户基本信息的处理函数
exports.updateUserInfo = (req, res) =&gt; {
  res.send(&#39;ok&#39;)
}
</code></pre><h3 id="3-2-2-">3.2.2 验证表单数据</h3>
<h4 id="1-schema-user-js-id-nickname-email-">1.在 /schema/user.js 验证规则模块中，定义 id，nickname，email 的验证规则如下：</h4>
<pre><code>// 定义 id, nickname, emial 的验证规则
const id = joi.number().integer().min(1).required()
const nickname = joi.string().required()
const email = joi.string().email().required()
</code></pre><h4 id="2-exports-">2.并使用 exports 向外共享如下的 验证规则对象：</h4>
<pre><code>// 验证规则对象 - 更新用户基本信息
exports.update_userinfo_schema = {
  body: {
    id,
    nickname,
    email,
  },
}
</code></pre><h4 id="3-router-userinfo-js-">3.在 /router/userinfo.js 模块中，导入验证数据合法性的中间件：</h4>
<pre><code>// 导入验证数据合法性的中间件
const expressJoi = require(&#39;@escook/express-joi&#39;)
</code></pre><h4 id="4-router-userinfo-js-">4.在 /router/userinfo.js 模块中，导入需要的验证规则对象：</h4>
<pre><code>// 导入需要的验证规则对象
const { update_userinfo_schema } = require(&#39;../schema/user&#39;)
</code></pre><h4 id="5-router-userinfo-js-">5.在 /router/userinfo.js 模块中，修改 更新用户的基本信息 的路由如下：</h4>
<pre><code>// 更新用户的基本信息
router.post(&#39;/userinfo&#39;, expressJoi(update_userinfo_schema), userinfo_handler.updateUserInfo)
</code></pre><h3 id="3-2-3-">3.2.3 实现更新用户基本信息的功能</h3>
<h4 id="1-sql-">1.定义待执行的 SQL 语句：</h4>
<blockquote>
<p>const sql = <code>update ev_users set ? where id=?</code></p>
</blockquote>
<h4 id="2-db-query-sql-">2.调用 db.query() 执行 SQL 语句并传参：</h4>
<pre><code>db.query(sql, [req.body, req.body.id], (err, results) =&gt; {
  // 执行 SQL 语句失败
  if (err) return res.cc(err)

  // 执行 SQL 语句成功，但影响行数不为 1
  if (results.affectedRows !== 1) return res.cc(&#39;修改用户基本信息失败！&#39;)

  // 修改用户信息成功
  return res.cc(&#39;修改用户基本信息成功！&#39;, 0)
})
</code></pre><h2 id="3-3-">3.3 重置密码</h2>
<h3 id="3-3-0-">3.3.0 实现步骤</h3>
<blockquote>
<p>1.定义路由和处理函数
2.验证表单数据
3.实现重置密码的功能</p>
</blockquote>
<h3 id="3-3-1-">3.3.1 定义路由和处理函数</h3>
<h4 id="1-router-userinfo-js-">1.在 /router/userinfo.js 模块中，新增 重置密码 的路由：</h4>
<pre><code>// 重置密码的路由
router.post(&#39;/updatepwd&#39;, userinfo_handler.updatePassword)
</code></pre><h4 id="2-router_handler-userinfo-js-">2.在 /router_handler/userinfo.js 模块中，定义并向外共享 重置密码 的路由处理函数：</h4>
<pre><code>// 重置密码的处理函数
exports.updatePassword = (req, res) =&gt; {
  res.send(&#39;ok&#39;)
}
</code></pre><h3 id="3-3-2-">3.3.2 验证表单数据</h3>
<blockquote>
<p>核心验证思路：旧密码与新密码，必须符合密码的验证规则，并且新密码不能与旧密码一致！</p>
</blockquote>
<h4 id="1-schema-user-js-exports-">1.在 /schema/user.js 模块中，使用 exports 向外共享如下的 验证规则对象：</h4>
<pre><code>// 验证规则对象 - 重置密码
exports.update_password_schema = {
  body: {
    // 使用 password 这个规则，验证 req.body.oldPwd 的值
    oldPwd: password,
    // 使用 joi.not(joi.ref(&#39;oldPwd&#39;)).concat(password) 规则，验证 req.body.newPwd 的值
    // 解读：
    // 1. joi.ref(&#39;oldPwd&#39;) 表示 newPwd 的值必须和 oldPwd 的值保持一致
    // 2. joi.not(joi.ref(&#39;oldPwd&#39;)) 表示 newPwd 的值不能等于 oldPwd 的值
    // 3. .concat() 用于合并 joi.not(joi.ref(&#39;oldPwd&#39;)) 和 password 这两条验证规则
    newPwd: joi.not(joi.ref(&#39;oldPwd&#39;)).concat(password),
  },
}
</code></pre><h4 id="2-router-userinfo-js-">2.在 /router/userinfo.js 模块中，导入需要的验证规则对象：</h4>
<pre><code>// 导入需要的验证规则对象
const { update_userinfo_schema, update_password_schema } = require(&#39;../schema/user&#39;)
</code></pre><h4 id="3-update_password_schema-">3.并在 重置密码的路由 中，使用 update_password_schema 规则验证表单的数据，示例代码如下：</h4>
<blockquote>
<p>router.post(&#39;/updatepwd&#39;, expressJoi(update_password_schema), userinfo_handler.updatePassword)</p>
</blockquote>
<h3 id="3-3-3-">3.3.3 实现重置密码的功能</h3>
<h4 id="1-id-">1.根据 id 查询用户是否存在：</h4>
<pre><code>// 定义根据 id 查询用户数据的 SQL 语句
const sql = `select * from ev_users where id=?`

// 执行 SQL 语句查询用户是否存在
db.query(sql, req.user.id, (err, results) =&gt; {
  // 执行 SQL 语句失败
  if (err) return res.cc(err)

  // 检查指定 id 的用户是否存在
  if (results.length !== 1) return res.cc(&#39;用户不存在！&#39;)

  // TODO：判断提交的旧密码是否正确
})
</code></pre><h4 id="2-">2.判断提交的 旧密码 是否正确：</h4>
<pre><code>// 在头部区域导入 bcryptjs 后，
// 即可使用 bcrypt.compareSync(提交的密码，数据库中的密码) 方法验证密码是否正确
// compareSync() 函数的返回值为布尔值，true 表示密码正确，false 表示密码错误
const bcrypt = require(&#39;bcryptjs&#39;)

// 判断提交的旧密码是否正确
const compareResult = bcrypt.compareSync(req.body.oldPwd, results[0].password)
if (!compareResult) return res.cc(&#39;原密码错误！&#39;)
</code></pre><h4 id="3-bcrypt-">3.对新密码进行 bcrypt 加密之后，更新到数据库中：</h4>
<pre><code>// 定义更新用户密码的 SQL 语句
const sql = `update ev_users set password=? where id=?`

// 对新密码进行 bcrypt 加密处理
const newPwd = bcrypt.hashSync(req.body.newPwd, 10)

// 执行 SQL 语句，根据 id 更新用户的密码
db.query(sql, [newPwd, req.user.id], (err, results) =&gt; {
  // SQL 语句执行失败
  if (err) return res.cc(err)

  // SQL 语句执行成功，但是影响行数不等于 1
  if (results.affectedRows !== 1) return res.cc(&#39;更新密码失败！&#39;)

  // 更新密码成功
  res.cc(&#39;更新密码成功！&#39;, 0)
})
</code></pre><h2 id="3-4-">3.4 更新用户头像</h2>
<h3 id="3-4-0-">3.4.0 实现步骤</h3>
<blockquote>
<p>1.定义路由和处理函数
2.验证表单数据
3.实现更新用户头像的功能</p>
</blockquote>
<h3 id="3-4-1-">3.4.1 定义路由和处理函数</h3>
<h4 id="1-router-userinfo-js-">1.在 /router/userinfo.js 模块中，新增 更新用户头像 的路由：</h4>
<pre><code>// 更新用户头像的路由
router.post(&#39;/update/avatar&#39;, userinfo_handler.updateAvatar)
</code></pre><h4 id="2-router_handler-userinfo-js-">2.在 /router_handler/userinfo.js 模块中，定义并向外共享 更新用户头像 的路由处理函数：</h4>
<pre><code>// 更新用户头像的处理函数
exports.updateAvatar = (req, res) =&gt; {
  res.send(&#39;ok&#39;)
}
</code></pre><h3 id="3-4-2-">3.4.2 验证表单数据</h3>
<h4 id="1-schema-user-js-avatar-">1.在 /schema/user.js 验证规则模块中，定义 avatar 的验证规则如下：</h4>
<pre><code>// dataUri() 指的是如下格式的字符串数据：
// data:image/png;base64,VE9PTUFOWVNFQ1JFVFM=
const avatar = joi.string().dataUri().required()
</code></pre><h4 id="2-exports-">2.并使用 exports 向外共享如下的 验证规则对象：</h4>
<pre><code>// 验证规则对象 - 更新头像
exports.update_avatar_schema = {
  body: {
    avatar,
  },
}
</code></pre><h4 id="3-router-userinfo-js-">3.在 /router/userinfo.js 模块中，导入需要的验证规则对象：</h4>
<blockquote>
<p>const { update_avatar_schema } = require(&#39;../schema/user&#39;)</p>
</blockquote>
<h4 id="4-router-userinfo-js-">4. 在 /router/userinfo.js 模块中，修改 更新用户头像 的路由如下：</h4>
<pre><code>router.post(&#39;/update/avatar&#39;, expressJoi(update_avatar_schema), userinfo_handler.updateAvatar)
</code></pre><h3 id="3-4-3-">3.4.3 实现更新用户头像的功能</h3>
<h4 id="1-sql-">1.定义更新用户头像的 SQL 语句：</h4>
<blockquote>
<p>const sql = &#39;update ev_users set user_pic=? where id=?&#39;</p>
</blockquote>
<h4 id="2-db-query-sql-">2.调用 db.query() 执行 SQL 语句，更新对应用户的头像：</h4>
<pre><code>db.query(sql, [req.body.avatar, req.user.id], (err, results) =&gt; {
  // 执行 SQL 语句失败
  if (err) return res.cc(err)

  // 执行 SQL 语句成功，但是影响行数不等于 1
  if (results.affectedRows !== 1) return res.cc(&#39;更新头像失败！&#39;)

  // 更新用户头像成功
  return res.cc(&#39;更新头像成功！&#39;, 0)
})
</code></pre><h1 id="4-">4. 文章分类管理</h1>
<h2 id="4-1-ev_article_cate-">4.1 新建 ev_article_cate 表</h2>
<pre><code>CREATE TABLE ev_article_cate (
    Id int primary key auto_increment,
    name varchar(255),
    alias varchar(255),
    is_delete int default 0
);
</code></pre><h3 id="4-1-2-">4.1.2 新增两条初始数据</h3>
<h2 id="4-2-">4.2 获取文章分类列表</h2>
<h3 id="4-2-0-">4.2.0 实现步骤</h3>
<blockquote>
<p>1.初始化路由模块
2.初始化路由处理函数模块
3.获取文章分类列表数据</p>
</blockquote>
<h3 id="4-2-1-">4.2.1 初始化路由模块</h3>
<h4 id="1-router-artcate-js-">1.创建 /router/artcate.js 路由模块，并初始化如下的代码结构：</h4>
<pre><code>// 导入 express
const express = require(&#39;express&#39;)
// 创建路由对象
const router = express.Router()

// 获取文章分类的列表数据
router.get(&#39;/cates&#39;, (req, res) =&gt; {
  res.send(&#39;ok&#39;)
})

// 向外共享路由对象
module.exports = router
</code></pre><h4 id="2-app-js-">2.在 app.js 中导入并使用文章分类的路由模块：</h4>
<pre><code>// 导入并使用文章分类路由模块
const artCateRouter = require(&#39;./router/artcate&#39;)
// 为文章分类的路由挂载统一的访问前缀 /my/article
app.use(&#39;/my/article&#39;, artCateRouter)
</code></pre><h3 id="4-2-2-">4.2.2 初始化路由处理函数模块</h3>
<h4 id="1-router_handler-artcate-js-">1.创建 /router_handler/artcate.js 路由处理函数模块，并初始化如下的代码结构：</h4>
<pre><code>// 获取文章分类列表数据的处理函数
exports.getArticleCates = (req, res) =&gt; {
  res.send(&#39;ok&#39;)
}
</code></pre><h4 id="2-router-artcate-js-">2.修改 /router/artcate.js 中的代码如下：</h4>
<pre><code>const express = require(&#39;express&#39;)
const router = express.Router()

// 导入文章分类的路由处理函数模块
const artcate_handler = require(&#39;../router_handler/artcate&#39;)

// 获取文章分类的列表数据
router.get(&#39;/cates&#39;, artcate_handler.getArticleCates)

module.exports = router
</code></pre><h3 id="4-2-3-">4.2.3 获取文章分类列表数据</h3>
<h4 id="1-router_handler-artcate-js-">1.在 /router_handler/artcate.js 头部导入数据库操作模块：</h4>
<pre><code>// 导入数据库操作模块
const db = require(&#39;../db/index&#39;)
</code></pre><h4 id="2-sql-">2.定义 SQL 语句：</h4>
<pre><code>// 根据分类的状态，获取所有未被删除的分类列表数据
// is_delete 为 0 表示没有被 标记为删除 的数据
const sql = &#39;select * from ev_article_cate where is_delete=0 order by id asc&#39;
</code></pre><h4 id="3-db-query-sql-">3.调用 db.query() 执行 SQL 语句：</h4>
<pre><code>db.query(sql, (err, results) =&gt; {
  // 1. 执行 SQL 语句失败
  if (err) return res.cc(err)

  // 2. 执行 SQL 语句成功
  res.send({
    status: 0,
    message: &#39;获取文章分类列表成功！&#39;,
    data: results,
  })
})
</code></pre><h2 id="4-3-">4.3 新增文章分类</h2>
<h3 id="4-3-0-">4.3.0 实现步骤</h3>
<blockquote>
<p>1.定义路由和处理函数
2.验证表单数据
3.查询 分类名称 与 分类别名 是否被占用
4.实现新增文章分类的功能</p>
</blockquote>
<h3 id="4-3-1-">4.3.1 定义路由和处理函数</h3>
<h4 id="1-router-artcate-js-">1.在 /router/artcate.js 模块中，添加 新增文章分类 的路由：</h4>
<pre><code>// 新增文章分类的路由
router.post(&#39;/addcates&#39;, artcate_handler.addArticleCates)
</code></pre><h4 id="2-router_handler-artcate-js-">2.在 /router_handler/artcate.js 模块中，定义并向外共享 新增文章分类 的路由处理函数：</h4>
<pre><code>// 新增文章分类的处理函数
exports.addArticleCates = (req, res) =&gt; {
  res.send(&#39;ok&#39;)
}
</code></pre><h3 id="4-3-2-">4.3.2 验证表单数据</h3>
<h4 id="1-schema-artcate-js-">1.创建 /schema/artcate.js 文章分类数据验证模块，并定义如下的验证规则：</h4>
<pre><code>// 导入定义验证规则的模块
const joi = require(&#39;@hapi/joi&#39;)

// 定义 分类名称 和 分类别名 的校验规则
const name = joi.string().required()
const alias = joi.string().alphanum().required()

// 校验规则对象 - 添加分类
exports.add_cate_schema = {
  body: {
    name,
    alias,
  },
}
</code></pre><h4 id="2-router-artcate-js-add_cate_schema-">2.在 /router/artcate.js 模块中，使用 add_cate_schema 对数据进行验证：</h4>
<pre><code>// 导入验证数据的中间件
const expressJoi = require(&#39;@escook/express-joi&#39;)
// 导入文章分类的验证模块
const { add_cate_schema } = require(&#39;../schema/artcate&#39;)

// 新增文章分类的路由
router.post(&#39;/addcates&#39;, expressJoi(add_cate_schema), artcate_handler.addArticleCates)
</code></pre><h3 id="4-3-3-">4.3.3 查询分类名称与别名是否被占用</h3>
<h4 id="1-sql-">1.定义查重的 SQL 语句：</h4>
<pre><code>// 定义查询 分类名称 与 分类别名 是否被占用的 SQL 语句
const sql = `select * from ev_article_cate where name=? or alias=?`
</code></pre><h4 id="2-db-query-">2.调用 db.query() 执行查重的操作：</h4>
<pre><code>// 执行查重操作
db.query(sql, [req.body.name, req.body.alias], (err, results) =&gt; {
  // 执行 SQL 语句失败
  if (err) return res.cc(err)

  // 判断 分类名称 和 分类别名 是否被占用
  if (results.length === 2) return res.cc(&#39;分类名称与别名被占用，请更换后重试！&#39;)
  // 分别判断 分类名称 和 分类别名 是否被占用
  if (results.length === 1 &amp;&amp; results[0].name === req.body.name) return res.cc(&#39;分类名称被占用，请更换后重试！&#39;)
  if (results.length === 1 &amp;&amp; results[0].alias === req.body.alias) return res.cc(&#39;分类别名被占用，请更换后重试！&#39;)

  // TODO：新增文章分类
})
</code></pre><h3 id="4-3-4-">4.3.4 实现新增文章分类的功能</h3>
<h4 id="1-sql-">1.定义新增文章分类的 SQL 语句：</h4>
<blockquote>
<p>const sql = <code>insert into ev_article_cate set ?</code></p>
</blockquote>
<h4 id="2-db-query-sql-">2.调用 db.query() 执行新增文章分类的 SQL 语句：</h4>
<pre><code>db.query(sql, req.body, (err, results) =&gt; {
  // SQL 语句执行失败
  if (err) return res.cc(err)

  // SQL 语句执行成功，但是影响行数不等于 1
  if (results.affectedRows !== 1) return res.cc(&#39;新增文章分类失败！&#39;)

  // 新增文章分类成功
  res.cc(&#39;新增文章分类成功！&#39;, 0)
})
</code></pre><h2 id="4-4-id-">4.4 根据 Id 删除文章分类</h2>
<h3 id="4-4-0-">4.4.0 实现步骤</h3>
<blockquote>
<p>1.定义路由和处理函数
2.验证表单数据
3.实现删除文章分类的功能</p>
</blockquote>
<h3 id="4-4-1-">4.4.1 定义路由和处理函数</h3>
<h4 id="1-router-artcate-js-">1.在 /router/artcate.js 模块中，添加 删除文章分类 的路由：</h4>
<pre><code>// 删除文章分类的路由
router.get(&#39;/deletecate/:id&#39;, artcate_handler.deleteCateById)
</code></pre><h4 id="2-router_handler-artcate-js-">2.在 /router_handler/artcate.js 模块中，定义并向外共享 删除文章分类 的路由处理函数：</h4>
<pre><code>// 删除文章分类的处理函数
exports.deleteCateById = (req, res) =&gt; {
  res.send(&#39;ok&#39;)
}
</code></pre><h3 id="4-4-2-">4.4.2 验证表单数据</h3>
<h4 id="1-schema-artcate-js-id-">1.在 /schema/artcate.js 验证规则模块中，定义 id 的验证规则如下：</h4>
<pre><code>// 定义 分类Id 的校验规则
const id = joi.number().integer().min(1).required()
</code></pre><h4 id="2-exports-">2.并使用 exports 向外共享如下的 验证规则对象：</h4>
<pre><code>// 校验规则对象 - 删除分类
exports.delete_cate_schema = {
  params: {
    id,
  },
}
</code></pre><h4 id="3-router-artcate-js-">3.在 /router/artcate.js 模块中，导入需要的验证规则对象，并在路由中使用：</h4>
<pre><code>// 导入删除分类的验证规则对象
const { delete_cate_schema } = require(&#39;../schema/artcate&#39;)

// 删除文章分类的路由
router.get(&#39;/deletecate/:id&#39;, expressJoi(delete_cate_schema), artcate_handler.deleteCateById)
</code></pre><h3 id="4-4-3-">4.4.3 实现删除文章分类的功能</h3>
<h4 id="1-sql-">1.定义删除文章分类的 SQL 语句：</h4>
<blockquote>
<p>const sql = <code>update ev_article_cate set is_delete=1 where id=?</code></p>
</blockquote>
<h4 id="2-db-query-sql-">2.调用 db.query() 执行删除文章分类的 SQL 语句：</h4>
<pre><code>db.query(sql, req.params.id, (err, results) =&gt; {
  // 执行 SQL 语句失败
  if (err) return res.cc(err)

  // SQL 语句执行成功，但是影响行数不等于 1
  if (results.affectedRows !== 1) return res.cc(&#39;删除文章分类失败！&#39;)

  // 删除文章分类成功
  res.cc(&#39;删除文章分类成功！&#39;, 0)
})
</code></pre><h2 id="4-5-id-">4.5 根据 Id 获取文章分类数据</h2>
<h3 id="4-5-0-">4.5.0 实现步骤</h3>
<blockquote>
<p>1.定义路由和处理函数
2.验证表单数据
3.实现获取文章分类的功能</p>
</blockquote>
<h3 id="4-5-1-">4.5.1 定义路由和处理函数</h3>
<h4 id="1-router-artcate-js-id-">1.在 /router/artcate.js 模块中，添加 根据 Id 获取文章分类 的路由：</h4>
<pre><code>router.get(&#39;/cates/:id&#39;, artcate_handler.getArticleById)
</code></pre><h4 id="2-router_handler-artcate-js-id-">2.在 /router_handler/artcate.js 模块中，定义并向外共享 根据 Id 获取文章分类 的路由处理函数：</h4>
<pre><code>// 根据 Id 获取文章分类的处理函数
exports.getArticleById = (req, res) =&gt; {
  res.send(&#39;ok&#39;)
}
</code></pre><h3 id="4-5-2-">4.5.2 验证表单数据</h3>
<h4 id="1-schema-artcate-js-exports-">1.在 /schema/artcate.js 验证规则模块中，使用 exports 向外共享如下的 验证规则对象：</h4>
<pre><code>// 校验规则对象 - 根据 Id 获取分类
exports.get_cate_schema = {
  params: {
    id,
  },
}
</code></pre><h4 id="2-router-artcate-js-">2.在 /router/artcate.js 模块中，导入需要的验证规则对象，并在路由中使用：</h4>
<pre><code>// 导入根据 Id 获取分类的验证规则对象
const { get_cate_schema } = require(&#39;../schema/artcate&#39;)

// 根据 Id 获取文章分类的路由
router.get(&#39;/cates/:id&#39;, expressJoi(get_cate_schema), artcate_handler.getArticleById)
</code></pre><h3 id="4-5-3-">4.5.3 实现获取文章分类的功能</h3>
<h4 id="1-id-sql-">1.定义根据 Id 获取文章分类的 SQL 语句：</h4>
<blockquote>
<p>const sql = <code>select * from ev_article_cate where id=?</code></p>
</blockquote>
<h4 id="2-db-query-sql-">2.调用 db.query() 执行 SQL 语句：</h4>
<pre><code>db.query(sql, req.params.id, (err, results) =&gt; {
  // 执行 SQL 语句失败
  if (err) return res.cc(err)

  // SQL 语句执行成功，但是没有查询到任何数据
  if (results.length !== 1) return res.cc(&#39;获取文章分类数据失败！&#39;)

  // 把数据响应给客户端
  res.send({
    status: 0,
    message: &#39;获取文章分类数据成功！&#39;,
    data: results[0],
  })
})
</code></pre><h2 id="4-6-id-">4.6 根据 Id 更新文章分类数据</h2>
<h3 id="4-6-0-">4.6.0 实现步骤</h3>
<blockquote>
<p>1.定义路由和处理函数
2.验证表单数据
3.查询 分类名称 与 分类别名 是否被占用
4.实现更新文章分类的功能</p>
</blockquote>
<h3 id="4-6-1-">4.6.1 定义路由和处理函数</h3>
<h4 id="1-router-artcate-js-">1.在 /router/artcate.js 模块中，添加 更新文章分类 的路由：</h4>
<pre><code>// 更新文章分类的路由
router.post(&#39;/updatecate&#39;, artcate_handler.updateCateById)
</code></pre><h4 id="2-router_handler-artcate-js-">2.在 /router_handler/artcate.js 模块中，定义并向外共享 更新文章分类 的路由处理函数：</h4>
<pre><code>// 更新文章分类的处理函数
exports.updateCateById = (req, res) =&gt; {
  res.send(&#39;ok&#39;)
}
</code></pre><h3 id="4-6-2-">4.6.2 验证表单数据</h3>
<h4 id="1-schema-artcate-js-exports-">1.在 /schema/artcate.js 验证规则模块中，使用 exports 向外共享如下的 验证规则对象：</h4>
<pre><code>// 校验规则对象 - 更新分类
exports.update_cate_schema = {
  body: {
    Id: id,
    name,
    alias,
  },
}
</code></pre><h4 id="2-router-artcate-js-">2.在 /router/artcate.js 模块中，导入需要的验证规则对象，并在路由中使用：</h4>
<pre><code>// 导入更新文章分类的验证规则对象
const { update_cate_schema } = require(&#39;../schema/artcate&#39;)

// 更新文章分类的路由
router.post(&#39;/updatecate&#39;, expressJoi(update_cate_schema), artcate_handler.updateCateById)
</code></pre><h3 id="4-5-4-">4.5.4 查询分类名称与别名是否被占用</h3>
<h4 id="1-sql-">1.定义查重的 SQL 语句:</h4>
<pre><code>// 定义查询 分类名称 与 分类别名 是否被占用的 SQL 语句
const sql = `select * from ev_article_cate where Id&lt;&gt;? and (name=? or alias=?)`
</code></pre><h4 id="2-db-query-">2.调用 db.query() 执行查重的操作：</h4>
<pre><code>// 执行查重操作
db.query(sql, [req.body.Id, req.body.name, req.body.alias], (err, results) =&gt; {
  // 执行 SQL 语句失败
  if (err) return res.cc(err)

  // 判断 分类名称 和 分类别名 是否被占用
  if (results.length === 2) return res.cc(&#39;分类名称与别名被占用，请更换后重试！&#39;)
  if (results.length === 1 &amp;&amp; results[0].name === req.body.name) return res.cc(&#39;分类名称被占用，请更换后重试！&#39;)
  if (results.length === 1 &amp;&amp; results[0].alias === req.body.alias) return res.cc(&#39;分类别名被占用，请更换后重试！&#39;)

  // TODO：更新文章分类
})
</code></pre><h3 id="4-5-5-">4.5.5 实现更新文章分类的功能</h3>
<h4 id="1-sql-">1.定义更新文章分类的 SQL 语句：</h4>
<blockquote>
<p>const sql = <code>update ev_article_cate set ? where Id=?</code></p>
</blockquote>
<h4 id="2-db-query-sql-">2.调用 db.query() 执行 SQL 语句：</h4>
<pre><code>db.query(sql, [req.body, req.body.Id], (err, results) =&gt; {
  // 执行 SQL 语句失败
  if (err) return res.cc(err)

  // SQL 语句执行成功，但是影响行数不等于 1
  if (results.affectedRows !== 1) return res.cc(&#39;更新文章分类失败！&#39;)

  // 更新文章分类成功
  res.cc(&#39;更新文章分类成功！&#39;, 0)
})
</code></pre><h1 id="5-">5. 文章管理</h1>
<h2 id="5-1-ev_articles-">5.1 新建 ev_articles 表</h2>
<pre><code>create table ev_articles(
    id int primary key auto_increment,
    title varchar(255),
    content text,
    cover_img varchar(255),
    pub_date varchar(255),
    state varchar(255),
    is_delete int,
    cate_id int,
    author_id int
);
</code></pre><h2 id="5-2-">5.2 发布新文章</h2>
<h3 id="5-2-0-">5.2.0 实现步骤</h3>
<blockquote>
<p>1.初始化路由模块
2.初始化路由处理函数模块
3.使用 multer 解析表单数据
4.验证表单数据
5.实现发布文章的功能</p>
</blockquote>
<h3 id="5-2-1-">5.2.1 初始化路由模块</h3>
<h4 id="1-router-article-js-">1.创建 /router/article.js 路由模块，并初始化如下的代码结构：</h4>
<pre><code>// 导入 express
const express = require(&#39;express&#39;)
// 创建路由对象
const router = express.Router()

// 发布新文章
router.post(&#39;/add&#39;, (req, res) =&gt; {
  res.send(&#39;ok&#39;)
})

// 向外共享路由对象
module.exports = router
</code></pre><h4 id="2-app-js-">2.在 app.js 中导入并使用文章的路由模块：</h4>
<pre><code>// 导入并使用文章路由模块
const articleRouter = require(&#39;./router/article&#39;)
// 为文章的路由挂载统一的访问前缀 /my/article
app.use(&#39;/my/article&#39;, articleRouter)
</code></pre><h3 id="5-2-2-">5.2.2 初始化路由处理函数模块</h3>
<h4 id="1-router_handler-article-js-">1.创建 /router_handler/article.js 路由处理函数模块，并初始化如下的代码结构：</h4>
<pre><code>// 发布新文章的处理函数
exports.addArticle = (req, res) =&gt; {
  res.send(&#39;ok&#39;)
}
</code></pre><h4 id="2-router-article-js-">2.修改 /router/article.js 中的代码如下：</h4>
<pre><code>const express = require(&#39;express&#39;)
const router = express.Router()

// 导入文章的路由处理函数模块
const article_handler = require(&#39;../router_handler/article&#39;)

// 发布新文章
router.post(&#39;/add&#39;, article_handler.addArticle)

module.exports = router
</code></pre><h3 id="5-2-3-multer-">5.2.3 使用 multer 解析表单数据</h3>
<blockquote>
<p>注意：使用 express.urlencoded() 中间件无法解析 multipart/form-data 格式的请求体数据。
当前项目，推荐使用 multer 来解析 multipart/form-data 格式的表单数据。<a href="https://www.npmjs.com/package/multer">https://www.npmjs.com/package/multer</a></p>
</blockquote>
<h4 id="1-multer-">1.运行如下的终端命令，在项目中安装 multer：</h4>
<blockquote>
<p>npm i <a href="mailto:multer@1.4.2">multer@1.4.2</a></p>
</blockquote>
<h4 id="2-router-article-js-multer-">2.在 /router/article.js 模块中导入并配置 multer：</h4>
<pre><code>// 导入解析 formdata 格式表单数据的包
const multer = require(&#39;multer&#39;)
// 导入处理路径的核心模块
const path = require(&#39;path&#39;)

// 创建 multer 的实例对象，通过 dest 属性指定文件的存放路径
const upload = multer({ dest: path.join(__dirname, &#39;../uploads&#39;) })
</code></pre><h4 id="3-">3.修改 发布新文章 的路由如下：</h4>
<pre><code>// 发布新文章的路由
// upload.single() 是一个局部生效的中间件，用来解析 FormData 格式的表单数据
// 将文件类型的数据，解析并挂载到 req.file 属性中
// 将文本类型的数据，解析并挂载到 req.body 属性中
router.post(&#39;/add&#39;, upload.single(&#39;cover_img&#39;), article_handler.addArticle)
</code></pre><h4 id="4-router_handler-article-js-addarticle-multer-">4.在 /router_handler/article.js 模块中的 addArticle 处理函数中，将 multer 解析出来的数据进行打印：</h4>
<pre><code>// 发布新文章的处理函数
exports.addArticle = (req, res) =&gt; {
  console.log(req.body) // 文本类型的数据
  console.log(&#39;--------分割线----------&#39;)
  console.log(req.file) // 文件类型的数据

  res.send(&#39;ok&#39;)
})
</code></pre><h3 id="5-2-4-">5.2.4 验证表单数据</h3>
<blockquote>
<p>实现思路：通过 express-joi 自动验证 req.body 中的文本数据；通过 if 判断手动验证 req.file 中的文件数据；</p>
</blockquote>
<h4 id="1-schema-article-js-">1.创建 /schema/article.js 验证规则模块，并初始化如下的代码结构：</h4>
<pre><code>// 导入定义验证规则的模块
const joi = require(&#39;joi&#39;)

// 定义 标题、分类Id、内容、发布状态 的验证规则
const title = joi.string().required()
const cate_id = joi.number().integer().min(1).required()
const content = joi.string().required().allow(&#39;&#39;)
const state = joi.string().valid(&#39;已发布&#39;, &#39;草稿&#39;).required()

// 验证规则对象 - 发布文章
exports.add_article_schema = {
  body: {
    title,
    cate_id,
    content,
    state,
  },
}
</code></pre><h4 id="2-router-article-js-">2.在 /router/article.js 模块中，导入需要的验证规则对象，并在路由中使用：</h4>
<pre><code>// 导入验证数据的中间件
const expressJoi = require(&#39;@escook/express-joi&#39;)
// 导入文章的验证模块
const { add_article_schema } = require(&#39;../schema/article&#39;)

// 发布新文章的路由
// 注意：在当前的路由中，先后使用了两个中间件：
//       先使用 multer 解析表单数据
//       再使用 expressJoi 对解析的表单数据进行验证
router.post(&#39;/add&#39;, upload.single(&#39;cover_img&#39;), expressJoi(add_article_schema), article_handler.addArticle)
</code></pre><h4 id="3-router_handler-article-js-addarticle-if-">3.在 /router_handler/article.js 模块中的 addArticle 处理函数中，通过 if 判断客户端是否提交了 封面图片：</h4>
<pre><code>// 发布新文章的处理函数
exports.addArticle = (req, res) =&gt; {
    // 手动判断是否上传了文章封面
  if (!req.file || req.file.fieldname !== &#39;cover_img&#39;) return res.cc(&#39;文章封面是必选参数！&#39;)

  // TODO：表单数据合法，继续后面的处理流程...
})
</code></pre><h3 id="5-2-5-">5.2.5 实现发布文章的功能</h3>
<h4 id="1-">1.整理要插入数据库的文章信息对象：</h4>
<pre><code>// 导入处理路径的 path 核心模块
const path = require(&#39;path&#39;)

const articleInfo = {
  // 标题、内容、状态、所属的分类Id
  ...req.body,
  // 文章封面在服务器端的存放路径
  cover_img: path.join(&#39;/uploads&#39;, req.file.filename),
  // 文章发布时间
  pub_date: new Date(),
  // 文章作者的Id
  author_id: req.user.id,
}
</code></pre><h4 id="2-sql-">2.定义发布文章的 SQL 语句：</h4>
<blockquote>
<p>const sql = <code>insert into ev_articles set ?</code></p>
</blockquote>
<h4 id="3-db-query-sql-">3.调用 db.query() 执行发布文章的 SQL 语句：</h4>
<pre><code>// 导入数据库操作模块
const db = require(&#39;../db/index&#39;)

// 执行 SQL 语句
db.query(sql, articleInfo, (err, results) =&gt; {
  // 执行 SQL 语句失败
  if (err) return res.cc(err)

  // 执行 SQL 语句成功，但是影响行数不等于 1
  if (results.affectedRows !== 1) return res.cc(&#39;发布文章失败！&#39;)

  // 发布文章成功
  res.cc(&#39;发布文章成功&#39;, 0)
})
</code></pre><h4 id="4-app-js-express-static-uploads-">4.在 app.js 中，使用 express.static() 中间件，将 uploads 目录中的图片托管为静态资源：</h4>
<pre><code>// 托管静态资源文件
app.use(&#39;/uploads&#39;, express.static(&#39;./uploads&#39;))
</code></pre>
          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>