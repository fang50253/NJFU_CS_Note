# 第四章 存储器管理 

## 4.1存储器的层次结构

### 4.1.1多级存储器结构

#### CPU寄存器

![](https://github.com/fang50253/NJFU_OS_NoteBook/blob/main/pic/4.1.1%E5%A4%9A%E7%BA%A7%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%93%E6%9E%84.png?raw=true)

### 4.1.2主存储器与寄存

* 主存储器：用来存放进程运行时的程序和数据。
* 寄存器：CPU中的部件，用来存放运算器的中间结果，容量很小，速度最快。一般只有几十个到上百个。

### 4.1.3高速缓存和磁盘缓存

* 高速缓存：根据程序执行的局部性原理（即程序在执行将呈现出局部性规律，在一较短的时间内，程序的执行仅局限于某个部分），将主存中一些经常访问的信息存放在高速缓存中，减少访问主存储器的次数，可提高程序执行速度。
* 磁盘缓存：由于目前磁盘的I/O速度远低于对主存的访问速度，因此将频繁使用的一部分磁盘数据和信息，暂时存放在磁盘缓存中，可减少访问磁盘的次数。

## 4.2程序的装入和链接

### 4.2.1程序的装入

#### 绝对装入方式(Absolute Loading Mode)

#### 可重定位装入方式(Relocation Loading Mode)

#### 动态运行时装入方式(Denamle Run-time Loading)

### 4.2.2程序的链接

#### 静态链接方式(Static Linking)   需解决的问题

* 对相对地址进行修改。 
* 变换外部调用符号。 

#### 装入时动态链接(Loadtime Dynamic Linking)   优点

* 便于修改和更新
* 便于实现对目标模块的共享

#### 运行时动态链接(Run-time Dynamic Linking) 

## 4.3连续分配方式

### 4.3.1单一连续分配

* 局限性：单用户、单任务

### 4.3.2固定分区分配

#### 划分分区的方法

* 特点：有n个分区，可以同时装入n个作业/任务
* 分区大小：相等(缺乏灵活性)、不相等(利用率更高)
* 内存分配：蒋分区的大小排序，并将其地址、分配标识符作记录
* 特点：简单、有碎片

#### 内存分配

### 4.3.3动态分区分配

#### 分区分配中的数据结构

#### 分区分配算法

##### 首次适应算法FF

* 要求：分区按低址――高址链接
* 特点：找到第一个大小满足的分区，划分出一块给申请者，余下的仍留空闲链中。低址内存使用频繁。

##### 循环首次适应算法

* 从1中上次找到的空闲分区的下一个开始查找，并循环查找。
* 特点：空闲分区分布均匀，提高了查找速度；缺乏大的空闲分区。

##### 最佳适应算法

* 该算法总是把既能满足要求，又是最小的空闲分区分配给作业。该算法要求将所有的空闲区按其大小排序后，以递增顺序形成一个空白链。这样每次找到的第一个满足要求的空闲区，必然是最优的。但每次分配后剩余的空间一定是最小的，在存储器中将留下许多难以利用的小空闲区。同时每次分配后必须重新排序，这也带来了一定的开销。

##### 最坏适应算法

* 按大小递减的顺序形成空闲区链，分配时直接从空闲区链的第一个空闲分区中分配（不能满足需要则不分配）。很显然，如果第一个空闲分区不能满足，那么再没有空闲分区能满足需要。这种分配方法初看起来不太合理，但它也有很强的直观吸引力：在大空闲区中放入程序后，剩下的空闲区常常也很大，于是还能装下一个较大的新程序。

  ##### 快速适应算法

* 将空闲分区按大小分类，为大小相同的分区建立空闲分区链表； 建立一张管理索引表，指向不同类型空闲分区链表的表头指针； 查找能满足进程需求的最小空闲区链表，取下第一块空闲区整体分配；

* 特点：能保留大的空闲区；分类搜索算法，存在多个空闲分区链表 以空间换时间，但是分区回收时较复杂。

#### 分区分配操作

##### 1）分配内存

##### 2）回收内存

* 当进程运行完毕释放内存时，系统根据回收区的首址，从空闲区链中找到相应的插入点，此时可能出现以下四种情况之一：
* 回收区与插入点的前一个分区相邻接，此时应将回收区与插入点的前一分区合并，不再为回收分区分配新表项，而只需修改F1区的大小；
* 回收分区与插入点的后一分区F2相邻接。此时也将两区合并形成新的空闲区，但用回收区的首址作为新空闲区的首址，大小为两者之和；
* 回收区同时与插入点的前、后两个分区邻接，此时将三个分区合并，使用F1的首址，取消F2的表项；
* 回收区既不与F1邻接，也不与F2邻接，这时应为回收区单独建立一新表项。填写回收区的首址和大小，并根据其首址，插入到空闲链中的适当位置。

### 4.3.4伙伴系统

* 分区大小为2^k(l≤ k ≤ m)，2^l表示最小分区大小， 2^m表示最大分区大小(初始为整个可分配内存的大小)；

### 4.3.5哈希算法

* 构造哈希函数，建立分区大小与空闲区表表头指针之间的对应关系，形成哈希表；
* 分区分配时，根据所需分区的大小，通过哈希函数的计算，得对应空闲区表的头指针，实现最佳分配。

### 4.3.6可重定位分区分配

#### 动态重定位的引入

* 在连续分配方式中，必须把一个系统顺序或用户程序，装入到一连续的内存空间中。如果在系统中有若干个小的分区，其总容量要装入的程序，但由于他们不相邻接，使该程序不能被装入内存。紧凑后，须对移动后的程序和数据进行重定位

#### 动态重定位的实现

* 在该方式中，将程序中的相对地址转换为物理地址的工作，被推迟到程序指令真正要执行时进行。因此，允许作业在运行过程中在内存中移动的技术，必须获得硬件地址变换机构的支持。即在系统中一个重定位寄存器，用它来装入（存放）程序在内存中的起始地址。

#### 动态重定位分区分配算法 

* 动态重定位分区分配算法与动态分区分配算法基本上相同；差别仅在于：在这种分配算法中，增加了“紧凑”功能，通常是在找不到足够大的空闲分区来满足用户需求时，进行紧凑。

### 4.3.7对换(Swapping) 

#### 对换

* 内容：是指把内存中暂时不能运行的进程或者暂时不用的程序和数据，调出到外存上，以便腾出足够的内存空间，再把已具备运行条件的进程或进程所需要的程序和数据，调入内存
* 作用：对换是提高内存利用率的有效措施。

#### 对换需要系统实现的功能

* 对对换空间的管理；
* 进程的换出；
* 进程的换入。

#### 对换空间的管理

* 配置相应的数据结构，以记录外存的使用情况

#### 进程的换出与换入 

##### 进程的换出

* 原因：每当一进程由于创建子进程而需要更多的内存空间，但又无足够的内存空间等情况发生时，系统应将某进程换出。
* 过程：系统首先选择处于阻塞状态且优先级最低的进程作为换出进程，然后启动盘块，将该进程的程序和数据传送到磁盘的对换区上。

##### 进程的换入

* 系统应定时地查看所有进程的状态，从中找出“就绪”状态但已换出的进程，将其中换出时间(换出到磁盘上)最久的进程作为换入进程，将之换入，直至已无可换入的进程或无可换出的进程为止。 

## 4.4基本分页存储管理方式

### 4.4.1页面和页表

#### 页面与页表

![](https://github.com/fang50253/NJFU_OS_NoteBook/blob/main/pic/4.4.1%E9%A1%B5%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png?raw=true)

* 分页存储管理，是将一个进程的逻辑地址空间分成若干个大小相等的片，称为页面或页，并为各页加以编号，从0开始，如第0页、第1页等。相应地，也把内存空间分成与页面相同大小的若干个存储块，称为(物理)块或页框(frame)， 也同样为它们加以编号，如0＃块、1＃块等等。在为进程分配内存时，以块为单位将进程中的若干个页分别装入到多个可以不相邻接的物理块中。由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为“页内碎片”。 
* 页表的结构：分页转换功能由驻留在内存中的表来描述，该表称为页表（page table），存放在物理地址空间中。页表可看做简单的若干个物理地址数组。线性到物理地址的映射功能可以简单地看做进行数组查找。线性地址的高位构成这个数组的索引值，用于选择对应页面的物理（基）地址。线性地址的低位给出了页面中的偏移量，加上页面的基地址最终形成对应的物理地址。
* 页面大小：在分页系统中的页面其大小应适中。页面若太小，一方面虽然可使内存碎片减小，从而减少了内存碎片的总空间， 有利于提高内存利用率，但另一方面也会使每个进程占用较多的页面，从而导致进程的页表过长，占用大量内存； 此外，还会降低页面换进换出的效率。然而，如果选择的页面较大，虽然可以减少页表的长度，提高页面换进换出的速度，但却又会使页内碎片增大。因此，页面的大小应选择得适中，且页面大小应是2的幂，通常为512 B~8 KB。 

#### 地址结构

#### 页表的功能

![](https://github.com/fang50253/NJFU_OS_NoteBook/blob/main/pic/4.4.1%E9%A1%B5%E8%A1%A8%E7%9A%84%E4%BD%9C%E7%94%A8.png?raw=true)

### 4.4.2地址变换机构

#### 基本的地址变换机构

#### 具有快表的地址变换机构

### 4.4.3两级和多级页表

#### 现代计算机的页表过大的解决方法

* ①采用离散分配方式来解决难以找到一块连续的大内存空间的问题
* ②只将当前需要的部分页表项调入内存， 其余的页表项仍驻留在磁盘上，需要时再调入。

#### 多级页表

## 4.5基本分段存储管理方式

### 4.5.1分段存储管理方式的引入的原因

* 方便编程
* 信息共享
* 信息保护
* 动态增长
* 动态链接

### 4.5.2分段系统的基本原理

#### 分段地址的结构

#### 段表

#### 地址变换机构

#### 分页和分段的主要区别

* 页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头， 提高内存的利用率。或者说， 分页仅仅是由于系统管理的需要而不是用户的需要。段则是信息的逻辑单位，它含有一组其意义相对完整的信息。 分段的目的是为了能更好地满足用户的需要。 
* 页的大小固定且由系统决定，由系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而在系统中只能有一种大小的页面；而段的长度却不固定， 决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分。
* 分页的作业地址空间是一维的，即单一的线性地址空间，程序员只需利用一个记忆符，即可表示一个地址； 而分段的作业地址空间则是二维的，程序员在标识一个地址时，既需给出段名， 又需给出段内地址。 

### 4.5.3信息共享

* 分段系统的一个突出的优点，便是易于实现段的共享，即允许若干个进程共享一个或多个段，而且对段的保护也十分简单易行。如果代码是可重入的（允许多个进程同时访问的代码，不允许任何进程在执行过程中对其有任何改变），则无论是在分页系统还是在分段系统中，该代码都能被共享。
* 以分时系统的多个用户共享文本编辑程序为例，在分页系统中，为实现代码的共享，应在每个进程的页表中，建立40个页表项，还需为自己的数据区建立页表项，而分段系统只需为文本编辑程序设置一个段表项。

### 4.5.4段页式存储管理方式

#### 地址变换过程

## 4.6虚拟存储器的基本概念

### 4.6.1虚拟存储器的引入

#### 引入原因

* 大作业所需空间超过内存空间
* 内存容量不足以容纳所有要运行的作业

#### 常规存储管理方式的特征

* 一次性：作业在运行前，需要一次性装入内存
* 驻留性：阻塞或已运行过不在运行的程序在结束前一直驻留内存

#### 局部性原理(1968年 Denning.P)

* 程序执行时， 除了少部分的转移和过程调用指令外，在大多数情况下仍是顺序执行的。
* 过程调用将会使程序的执行轨迹由一部分区域转至另一部分区域， 但经研究看出，过程调用的深度在大多数情况下都不超过5。
* 程序中存在许多循环结构， 这些虽然只由少数指令构成， 但是它们将多次执行。
* 程序中还包括许多对数据结构的处理， 如对数组进行操作， 它们往往都局限于很小的范围内。 

#### 局限性表现的两个具体方面

* 时间局限性。如果程序中的某条指令一旦执行， 则不久以后该指令可能再次执行；如果某数据被访问过， 则不久以后该数据可能再次被访问。产生时间局限性的典型原因，是由于在程序中存在着大量的循环操作。
* (2) 空间局限性。一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，其典型情况便是程序的顺序执行。

#### 虚拟存储器定义

* 具有请求调入功能和置换功能， 能从逻辑上对内存容量加以扩充的一种存储器系统。

### 4.6.2虚拟存储器的实现方法

#### 分页请求系统

* 硬件支持：① 请求分页的页表机制，它是在纯分页的页表机制上增加若干项而形成的，作为请求分页的数据结构；② 缺页中断机构，即每当用户程序要访问的页面尚未调入内存时 便产生一缺页中断，以请求OS将所缺的页调入内存；③ 地址变换机构， 它同样是在纯分页地址变换机构的基础上发展形成的。 
* 实现请求分页的软件

#### 请求分段系统

* （1）请求分段的段表机制。这是在纯分段的段表机制基础上，增加若干项而形成的；
* （2）缺段中断机构。每当用户程序所要访问的段尚未调入内存时，产生一缺段中断，请求OS将所缺的段调入内存；
* （3）地址变换机构：实现分页请求和请求分段的请求调页或段和置换功能都需要得到OS的支持。

### 4.6.3虚拟存储器的特征

* 离散性
* 多次性
* 对换性
* 虚拟性

## 4.7请求分页存储管理方式

### 4.7.1请求分页中的硬件支持

* 页表机制
* 分页中断机构
* 地址变换机构

### 4.7.2内存分配策略和分配方法

#### 最小物理块数的确定

* 进程应获得的最少物理块数与计算机的硬件结构有关，取决于指令的格式、 功能和寻址方式

#### 物理块的分配策略

* 1) 固定分配局部置换(Fixed Allocation, Local Replacement)：为每个进程分配一固定页数的内存空间，在整个运行期间都不再改变，只能从该进程在内存的n个页面中选出一页换出，然后再调入一页以保证分配给该进程的内存空间不变
* 2) 可变分配全局置换(Variable Allocation, Global Replacement)：系统中的每个进程分配一定数目的物理块，而OS自身也保持一个空闲物理块队列。
* 3) 可变分配局部置换(Variable Allocation, Local Replacemen)：进程分配一定数目的内存空间，但当某种进程发生缺页时，只允许从该进程在内存页面中选出一页换出，若某进程频繁地发生缺页中断，为该进程分配若干个附加的物理块，缺页率减低到适当程度为止。若某进程缺页率较低，适当减少分配给该进程的物理块。总之维持一个适当的缺页率。

#### 物理块分配算法

* 平均分配算法
* 按比例分配算法
* 考虑优先权的分配算法

### 4.7.3调页策略

#### 何时调入页面

* 预调页策略：采用一种以预测为基础的预调页策略；预计在不久之后便会被访问的程序或数据所在的页面，预先调入内存，目前预调页的成功率仅约50%。这种策略主要用于进程首次调入时，由程序员指出应该先调入哪些页。
* 请求调页策略：当进程在运行中需要访问某部分程序的数据时，发现其所在的页面不在内存，需立即提出请求，由系统将其所需页面调入内存。由请求调页策略所确定调入的页，是一定会被访问的，再加之请求调页策略比较易于实现，故在目前的虚拟存储器中，大多采用此策略。
* 确定从何处调入页面：       在请求分页系统中的外存分为两部分：用于存放文件的文件区和用于存放对换页面的对换区。通常，由于对换区是采用连续分配方式，而文件是采用离散分配方式，故对换区的磁盘I/O速度比文件区的高。这样，每当发生缺页请求时，系统应从何处将缺页调入内存，可分成如下三种情况： (1) 系统拥有足够的对换区空间，这时可以全部从对换区调入所需页面，以提高调页速度。为此，在进程运行前， 便须将与该进程有关的文件，从文件区拷贝到对换区。       (2) 系统缺少足够的对换区空间，这时凡是不会被修改的文件，都直接从文件区调入；而当换出这些页面时，由于它们未被修改而不必再将它们换出，以后再调入时，仍从文件区直接调入。但对于那些可能被修改的部分，在将它们换出时，便须调到对换区，以后需要时，再从对换区调入。(3) UNIX方式。由于与进程有关的文件都放在文件区，故凡是未运行过的页面，都应从文件区调入。而对于曾经运行过但又被换出的页面，由于是被放在对换区，因此在下次调入时，应从对换区调入。由于UNIX系统允许页面共享，因此， 某进程所请求的页面有可能已被其它进程调入内存，此时也就无须再从对换区调入。 

#### 页面调入过程

* 每当程序所要访问的页面未在内存时，便向CPU发出一缺页中断，中断处理程序首先保留CPU环境，分析中断原因后， 转入缺页中断处理程序。该程序通过查找页表，得到该页在外存的物理块后， 如果此时内存能容纳新页，则启动磁盘I/O将所缺之页调入内存，然后修改页表。如果内存已满，则须先按照某种置换算法从内存中选出一页准备换出；如果该页未被修改过，可不必将该页写回磁盘；但如果此页已被修改， 则必须将它写回磁盘，然后再把所缺的页调入内存， 并修改页表中的相应表项，置其存在位为“1”，并将此页表项写入快表中。在缺页调入内存后，利用修改后的页表， 去形成所要访问数据的物理地址，再去访问内存数据。 

## 4.8页面置换算法

### 4.8.1最佳置换算法和先进先出置换算法

#### 最佳(Optimal)置换算法

* 原理：其所选择的被淘汰页面，将是以后永不使用的， 或许是在最长(未来)时间内不再被访问的页面。采用最佳置换算法，通常可保证获得**最低**的缺页率。
* 局限性：采用最佳置换算法可保证获得最低的缺页率。但由于人们目前还无法预知一个进程在内存的若干个页面中，哪一个页面是未来最长时间内不在被访问的，因而该算法也是无法实现的，但是可利用该算法去评价其它算法。

![](https://github.com/fang50253/NJFU_OS_NoteBook/blob/main/pic/4.8.1%E6%9C%80%E4%BD%B3%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.png?raw=true)

#### 先进先出(FIFO)页面置换算法

* 原理：选择在内存中的驻留时间最久的页面予以淘汰。
* 优点：该算法实现简单，只需把一个进程已调入内存的页面，按先后次序链接成一个队列，并设置一个指针，称为替换指针，使它总是指向最老页面
* 缺点：与进程实际运行的规律不相适应，有些页面经常被访问，含有全局变量、常用函数、例程等的页面，FIFO置换算法并不能保证这些页面不被淘汰。

![](https://github.com/fang50253/NJFU_OS_NoteBook/blob/main/pic/4.8.2%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.png?raw=true)

### 4.8.2最近最久未使用(LRU)置换算法

![](https://github.com/fang50253/NJFU_OS_NoteBook/blob/main/pic/4.8.2%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.png?raw=true)



### 4.8.3Clock置换算法 

* (1) 从指针所指示的当前位置开始， 扫描循环队列， 寻找A=0且M=0的第一类页面， 将所遇到的第一个页面作为所选中的淘汰页。 在第一次扫描期间不改变访问位A。
* (2) 如果第一步失败，即查找一周后未遇到第一类页面， 则开始第二轮扫描，寻找A=0且M=1的第二类页面，将所遇到的第一个这类页面作为淘汰页。在第二轮扫描期间，将所有扫描过的页面的访问位都置0。
* (3) 如果第二步也失败，亦即未找到第二类页面，则将指针返回到开始的位置，并将所有的访问位复0。 然后重复第一步，如果仍失败，必要时再重复第二步，此时就一定能找到被淘汰的页。 

![](https://github.com/fang50253/NJFU_OS_NoteBook/blob/main/pic/4.8.3%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.png?raw=true)

### 4.8.4其他置换算法

* 最少使用(LFU： Least Frequently Used)置换算法
* 页面缓冲算法(PBA： Page Buffering Algorithm)

## 4.9请求分段存储管理方式

### 4.9.1 请求分段中的硬件支持

* 段表：在段表项中， 除了段名(号)、 段长、 段在内存中的起始地址外， 还增加了以下诸项：（1）存取方式。 00(可执行)；01(可读)；11(可写)；(2) 访问字段A。被访问次数 (3) 修改位M。是否被修改过(4) 存在位P。 是否已调入内存(5) 增补位。 运行过程中是否增长过(6) 外存始址。硬盘的块号 （如果在硬盘上）

### 4.9.2分段的共享与保护

#### 共享段段分配和回收

* 共享段的分配：在为共享段分配内存时，对第一个请求使用该共享段的进程，由系统为该共享段分配一物理区，再把共享段调入该区，同时将该区的始址填入请求进程的段表的相应项中，还须在共享段表中增加一表项，填写有关数据，把count置为1；之后，当又有其它进程需要调用该共享段时，由于该共享段已被调入内存，故此时无须再为该段分配内存，而只需在调用进程的段表中，增加一表项，填写该共享段的物理地址；在共享段的段表中，填上调用进程的进程名、存取控制等，再执行count∶=count+1操作，以表明有两个进程共享该段。 
* 共享段的回收：当共享此段的某进程不再需要该段时，应将该段释放， 包括撤消在该进程段表中共享段所对应的表项，以及执行count∶=count-1操作。若结果为0，则须由系统回收该共享段的物理内存，以及取消在共享段表中该段所对应的表项， 表明此时已没有进程使用该段；否则(减1结果不为0)， 则只是取消调用者进程在共享段表中的有关记录。 

#### 分段保护 

##### 越界检查

* 在段表寄存器中放有段表长度信息，同样，在段表中也为每个段设置有段长字段。在进行存储访问时，首先，将逻辑地址空间的段号与段表长度进行比较，如果段号等于或大于段表长度，将发出地址越界中断信号；其次，还要检查段内地址是否等于或大于段长，若是大于段长，将产生地址越界中断信号，从而保证了每个进程只能在自己的地址空间内运行。

##### 存取控制检查：在段表的每个表项中，都设置了一个“存取控制”字段，用于规定对该段的访问方式。通常的访问方式有：

* 只读。只允许程序对该段中的程序或数据进行读访问；
* 只执行。只允许程序调用该段去执行，但不准读该段的内容，也不允许对该段执行写操作；
* 读/写。允许程序对该段进行读写访问。

##### 环保护机构：一种功能较完善的保护机构。在该机制中规定：低编号的环具有高优先权，OS核心处于0环内；某些重要的实用程序和操作系统服务，占居中间环；而一般的应用程序，则被安排在外环上。在环系统中，程序的访问和调用应遵循以下规则：

* 一个程序可以访问驻留在相同环或较低特权环中的数据。 
* 一个程序可以调用驻留在相同环或较高特权环中的服务。 
