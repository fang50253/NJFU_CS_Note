# 第三章 处理剂调度与死锁
## 3.1处理剂调度的层次
### 3.1.1高级调度
#### 作业和作业步
* 作业(Job)：包含通常的程序和数据，配有一份作业说明书，系统根据说明书来对程序的运行进行控制。
* 作业步(Job Step)：把每一个加工步骤称为一个作业步。例如，一个作业可分成3个作业步：① “编译”作业步，通过执行编译程序对源程序进行编译，产生若干个目标程序段；② “连结装配”作业步，将“编译”作业步所产生的若干个目标程序段装配成可执行的目标程序；③ “运行”作业步，将可执行的目标程序读入内存并控制其运行。
* 作业流。若干个作业进入系统后，被依次存放在外存上，这便形成了输入的作业流；在操作系统的控制下，逐个作业进行处理，形成了处理作业流。
#### 作业控制块JCB(Job Control Block)
* 是作业在系统中存在的标志，保存了系统对作业进行管理和调度所需的全部信息。包含：作业标识、用户名称、用户帐户、作业类型(CPU 繁忙型、I/O 繁忙型、批量型、终端型)、作业状态、调度信息(优先级、作业已运行时间)、资源需求(预计运行时间、要求内存大小、要求I/O设备的类型和数量等)、进入系统时间、开始处理时间、作业完成时间、作业退出时间、资源使用情况等。 
#### 作业调度
* 决定接纳多少个作业
* 决定接纳那些作业
### 3.1.2低级调度
#### 功能
* 保存处理剂的现场信息
* 按某种算法选取进程
* 把处理器分配给进程
#### 进程调度中的三个基本机制
* 排队器：将系统中所有的就绪进程按照一定的方式排成一个或多个队列，以便调度程序能最快地找到它。
* 分派器(分派程序)：把由进程调度程序所选定的进程，然后进行上下文切换，将处理机分配给它。 
* 上下文切换机制：当处理机进行切换时，会发生对上下文的切换操作。
#### 进程调度方式
* 非抢占方式(Nonpreemptive Mode)：这种调度方式的优点是实现简单，系统开销小，适用于大多数的批处理系统环境。但它难以满足紧急任务的要求——立即执行，因而可能造成难以预料的后果。在要求比较严格的实时系统中，不宜采用这种调度方式。
* 抢占方式(Preemptive Mode)：优先权原则(允许优先权高的新到进程抢到站当前进程的处理机)、短作业优先原则(转作业可以抢占当前教程作业的处理机)、时间片原则(各进城安时间片轮流运行，当一个时间用完后便停止该进程的执行而重新进行的度)。
#### 可能引起进程调度的因素可归结为如下几个
* 正在执行的进程执行完毕，因发生某事件而不能再继续执行；
* 执行中的进程因提出I/O请求而暂停执行；
* 在进程通信或同步过程中执行了某种原语操作，如P操作(wait操作)、Block原语、Wakeup原语
### 3.1.3中级调度
* 目的：主要目的是为了提高内存利用率和系统吞吐量。
## 3.2调度队列模型和调度准则
### 3.2.1调度队列模型
#### 仅有进程调度的调度队列模型：每个进程执行时可能出现的三种情况
* 任务在给定的时间片内已经完成，该进程便在释放处理机后进入完成状态
* 任务在本次分得的时间片内尚未完成，OS便将该任务再放入就绪队列的末尾
* 在执行期间，进程因为某事件而被阻塞后，被OS放入阻塞队列
#### 具有高级和低级调度的调度队列模型：与上一模型存在如下区别
* 就绪队列的形式：最常用的就绪队列形式是优先权队列。
* 设置多个阻塞队列：对于小型系统，可以只设置一个阻塞队列。在大、中型系统中设置若干个阻塞队列，每个队列对应某一种进程阻塞事件。 
#### 同时具有三级调度的调度队列模型
### 3.2.2选择调度方式和调度算法的若干准则
#### 面向用户的准则
* 周转时间(从作业被提交给系统开始，到作业完成为止的这段时间间隔，包括在后备队列等待调度时间、在就绪队列上的等待时间，在CPU上的执行时间、I/O操作完成时间)短。通常把周转时间的长短作为评价批处理系统的性能、选择作业调度方式与算法的重要准则之一。
* 响应时间快：常把响应时间的长短用来评价分时系统的性能，这是选择分时系统中进程调度算法的重要准则之一。
* 截止时间的保证，评价实时系统性能的重要指标
* 优先权准则：在批处理、分时和实时系统中选择调度算法时，都可遵循优先权准则，以便让某些紧急的作业能得到及时处理。
#### 面向系统准则
* 系统吞吐量高：用于评价批处理系统性能的另一个重要指标，因而是选择批处理作业调度的重要准则。 
* 处理机利用率好。
* 各类资源的平衡利用。
## 3.3调度算法
### 3.3.1 先来先服务和短作业(进程)优先调度算法
#### 先来先服务调度算法 FCFS
![FCFS.png](https://cdn.acwing.com/media/article/image/2024/11/21/383173_6da53fe0a7-FCFS.png) 
* 特点：有利于长作业（进程），而不利于短作业（进程）
#### 短作业(进程)优先调度算法 SJ(P)F 
![SJF.png](https://cdn.acwing.com/media/article/image/2024/11/21/383173_93450af7a7-SJF.png) 
* 特点：是从就绪队列中选出一估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时，再重新调度。
* 缺点：对长作业不利，没有考虑作业的紧迫程度，不一定能真正做到短作业优先调度
### 3.3.2高优先权优先调度算法
#### 优先权调度算法
* 非抢占式：主要用于批处理系统中；也可用于对实时性要求不严的实时系统中。  
* 抢占式：执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程的执行，重新将处理机分配给新到的优先权最高的进程。
#### 优先权的类型
##### 静态优先权(创建进程时确定，在运行期间保持不变)，依据
* 进程类型
* 进程对资源的需求
* 用户要求
##### 动态优先权
#### 高响应比优先调度算法
* 如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而该算法有利于短作业。
* 当要求服务的时间相同时，作业的优先权决定于等待时间，等待时间愈长，其优先权愈高，因而它实现的是先来先服务。
* 对于长作业，优先级可以随等待时间的增加而提高，当等待时间足够长时，其优先级便可升到很高，从而也可获得处理机。  
### 3.3.3 基于时间片的轮转调度算法 
* 时间便轮转法：可以保证就绪队列中的所有进程，在一给定的时间内，均能获得一时间片的处理机执行时间。
* 多级反馈队列调度算法(不必预先知道进程执行的所需时间)
#### 多级反馈队列调度算法的性能
* 终端型作业用户。作业较小，基本在第一时间片完成。 
* 短批处理作业用户。 周转较短。
* 长批处理作业用户。不必担心长期得不到处理。
## 3.4实时调度
### 3.4.1实现实时调度的基本条件
* 提供必要的信息：就绪时间、开始截止时间和完成截止时间、处理时间、资源要求、优先级。  
* 系统处理能力强
* 采用抢占式调度机制：当一个优先权更高的任务到达使允许将当前任务暂时挂起，而令优先权更高的任务立即投入运行。
* 具有快速切换机制：对外部中断快速响应能力、快速的任务分配能力
### 3.4.2实时调度算法的分类
#### 非抢占式调度算法
* 非抢占式轮转调度算法 !
* 非抢占式优先调度算法
#### 抢占式调度算法
* 基于始终中断的抢占式优先权调度算法
* 立即抢占(Immediate Preemption)的优先权调度算法
### 3.4.3常用的几种实时调度算法
#### 最早截止时间优先即EDF算法
* 非抢占式调度方式用于非周期实时任务
* 抢占式调度方式用于周期实时任务
* 详细描述：有两个周期性任务，任务A的周期时间为20 ms，每个周期的处理时间为10 ms；任务B的周期时间为50 ms，每个周期的处理时间为25 ms。图中的第一行示出了两个任务的到达时间、最后期限和执行时间图。其中任务A的到达时间为0、20、40、…；任务A的最后期限为20、40、60、…；任务B的到达时间为0、50、100、…；任务B的最后期限为50、100、150、…(注：单位皆为ms)。 
#### 最低松弛度优先即LLF(Least Laxity First)算法
* 该算法主要用于可抢占调度方式中。
* 详细描述：该算法是根据任务紧急(或松弛)的程度，来确定任务的优先级.例如，一个任务在200ms时必须完成，而它本身所需的运行时间就有100ms，调度程序必须在100 ms之前调度执行，该任务的松弛度为100 ms。又如，另一任务在400 ms时必须完成，它本身需要运行 150 ms，则其松弛度为 250 ms。在实现该算法时要求系统中有一个按松弛度排序的实时任务就绪队列，松弛度最低的任务排在队列最前面，调度程序总是选择就绪队列中的队首任务执行。
### 3.4.4优先级倒置
#### 问题由来
* 首先假设现在有三个任务P1， P2， P3（优先级分别是：３,２,１）；他们的优先级关系是：P3 ＜P2＜P1并且P1和P3需要访问共享资源。当一个P1任务通过互斥机制（mutex）访问共享资源时，如果该mutex已被一个低优先级任务（任务P3）占用（lock），那么P1也只好阻塞了 。
* 这个P3任务正在访问共享资源时,可能又被其他一些中等优先级的任务（任务P2）抢先了，只有等待P2执行结束，P3才能执行，释放共享资源，然后P1再执行。任务P1（优先级比任务P2高）除了需要的共享资源外运行任务的条件都满足了，却因为P2的运行被阻塞。这样系统的实时性得不到保证，这就是优先级倒置问题。
#### 解决方法
* 方法1：将程序代码进行适当的组织安排，避免优先级倒置的发生。
* 方法2：将占有互斥体的进程优先级提升到所有正在等待该互斥体的进程优先级的最高值。
* 方法3：每个互斥体都被分配一个优先级，该优先级通常与所有可以拥有该互斥体的进程中的最高优先级相对应。当优先级较低的进程占有互斥体后，该进程的优先级被提升到该互斥体的优先级。
## 3.5产生死锁的原因和必要条件
### 3.5.1产生死锁的原因
#### 竞争资源
* 1) 可剥夺和非剥夺性资源。可剥夺：可被优先级高的剥夺。
* 2) 竞争非剥夺性资源。 
* 3) 竞争临时性资源 
#### 进程推进顺序不当引起死锁
### 3.5.2产生死锁的必要条件
* 互斥条件 ：某资源只能由一个进程占用。
* 请求和保持条件：占有一个资源，请求新资源，但不放弃占有的资源，而新资源已被其它进程占用。 
* 不剥夺条件 ：已获得的资源不能被剥夺，只能靠自己释放。
* 环路等待条件 ：存在一个进程—资源的环形链。
### 3.5.3处理死锁的基本方法
* (1) 预防死锁：通过破坏死锁的四个必要条件中的一个或多个，来预防死锁。 
* (2) 避免死锁：在资源动态分配过程中，用某种方法防止系统进入不安全状态，从而避免发生死锁。 
* (3) 检测死锁：通过系统所设置的检测机构，及时地检测出死锁的发生，并精确地确定与死锁有关的进程和资源。
* (4) 解除死锁：当检测机构检测到系统中发生死锁时，将进程从死锁中解脱出来。
## 3.6预防死锁的方法
### 3.6.1预防死锁：使上述条件中的2、3、4有一个不成立即可
#### 摈弃“请求和保持“条件
* 优点：简单，易于实现且很安全
* 缺点：资源严重被浪费。
* 实现原理：系统规定所有进程在开始运行之前，都必须一次性地申请其在整个运行过程所需的全部资源。若申请的某类资源足够，则把所有资源分配给该进程，这样摒弃了“请求”条件。若资源不够，即使其它资源空闲，也不分配该进程，而让进程等待。由于在该进程等待期间，它并未占任何有资源，因而也摒弃了“保持”条件。
#### 摒弃“不剥夺”条件
* 缺点：实现复杂，延长了进程的周转时间，增加了系统开销，降低了系统的吞吐量。
* 实现原理：在采用这种方法时，进程逐个地提出对资源的要求。当一个已经保持了某些资源的进程，再提出新的资源请求而不能得到满足时，必须释放它已经保持了的所有资源，待以后需要时再申请，从而摒弃了“不剥夺”条件。
#### 摒弃“环路等待”条件
* 优点：资源利用率，系统吞吐量比较高。
* 缺点：限制了新类型设备的增加；有时造成资源浪费；增加了限制条件，影响用户简单、自主地编程。
* 在这种方法中，系统将所有资源按类型进行线性排队，并赋予不同的序号。所有进程对资源的请求必须严格按照资源序号的次序提出申请。这样，在所形成的资源分配图中，不可能再出现环路，因而摒弃了“环路等待条件”。
### 3.6.2系统安全状态
#### 安全状态
* 在避免死锁的方法中，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次资源分配的安全性。
* 若此次分配不会导致系统进入不安全状态，则将资源分配给进程； 否则，令进程等待。
#### 由安全状态向不安全状态的转换
* 如果不按照安全序列分配资源，则系统可能会由安全状态进入不安全状态。
### 3.6.2利用银行家算法避免死锁
![银行家.png](https://cdn.acwing.com/media/article/image/2024/11/21/383173_cf5224a5a7-银行家.png) 
#### 银行家算法中的数据结构
* 可用资源向量Available
* 最大需求矩阵Max
* 分配矩阵Allocation
* 需求矩阵Need
#### 银行家算法
* 设Requesti是进程Pi的请求向量，如果Requesti［j］=K，表示进程Pi需要K个Rj类型的资源。当Pi发出资源请求后，系统按下述步骤进行检查： (1) 如果Requesti［j］≤Need［i,j］，便转向步骤2；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。
* 如果Requesti［j］≤Available［j］，便转向步骤(3)；否则， 表示尚无足够资源，Pi须等待。
* 系统试探着把资源分配给进程Pi，并修改下面数据结构中的数值：
```     
Available[j]=Available[j]-Requesti[j];
Allocation[i,j]=Allocation[i,j]+Requesti［j］;
Need［i,j］=Need［i,j］-Requesti［j］;
```
* 系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，才正式将资源分配给进程Pi，以完成本次分配；否则， 将本次的试探分配作废，恢复原来的资源分配状态，让进程Pi等待。 
#### 安全性算法
* 设置两个向量：① 工作向量Work: 表示系统可供进程继续运行所需的各类资源数目,它有m个元素，开始时，Work=Available; ② Finish: 表示系统是否有足够的资源分配给进程，使之运行完成。开始时,Finish[i]=false; 当有足够资源分配给进程时， 再令Finish[i]=true。 
* 从进程集合中找到一个能满足下述条件的进程：① Finish[i]=false; ② Need[i,j]≤Work[j]；若找到，执行步骤(3)， 否则，执行步骤(4)。
* 当进程Pi获得资源后，可顺利执行至完成，并释放分配给它的资源，故应执行：
```
Work［j］=Work［j］+Allocation［i,j］;
Finish［i］=true;
go to step 2; 
```
* 所有进程的Finish[i]=true，表示系统处于安全状态；否则，系统处于不安全状态。 
## 3.7死锁的检测与解除
### 3.7.1死锁的检测
* ①保存有关资源的请求和分配信息。
* ②提供一种算法，以利用这些信息来检测系统是否已进入死锁。
#### 资源分配图(Resource Allocation Graph)
![资源分配图.png](https://cdn.acwing.com/media/article/image/2024/11/21/383173_ebcecdefa7-资源分配图.png) 
#### 死锁定理
* 在资源分配图中，找出一个既不阻塞又非独立的进程Pi，在顺利的情况下，Pi可获得所需资源而继续执行，直至完成，再释放占有的全部资源。相当于消去Pi的请求边和分配边。
* P1释放资源后，可使P2获得资源而继续运行。直至进程P2完成，释放全部资源。
* 在一系列的简化后，若能消去所有的边，使所有的进程节点都成为孤立节点，则称该图是可完全简化的。
* 否则不是完全简化的。
#### 死锁检测中的数据结构
3. 死锁检测中的数据结构
* 可利用资源向量Available，它表示了m类资源中每一类资源的可用数目。
* 把不占用资源的进程记入L表中,即Li∪L。 
* 从进程集合中找Requesti≤Work的进程，做如下处理：将其资源分配图简化，释放出资源，增加工作向量Work=Work+Allocationi，并将它记入L表中。若不能把所有进程都记入L表中， 便表明系统状态S的资源分配图是不可完全简化的。 因此，该系统状态将发生死锁。 
### 3.7.2死锁的解除
#### 剥夺资源
#### 撤销进程